using System;
using System.Collections.Generic;
using System.Linq;
using UnityEngine;

public class PersistentLaserBeam : LaserBeam
{
    [SerializeField] private float duration = 5f;
    [Tooltip("Time between each damage")]
    [SerializeField] private float damageTime = 0.3f;

    private float _currentDamageTime = 0f;
    private bool _canDamage;
    private int _submoduleIndex;
    
    protected override void Start()
    {
        EventManager.Instance.Subscribe(EventManager.NameEvent.OnStunnedSubmodule, OnSubmoduleStunned);
        
        Destroy(gameObject, duration);
    }

    public override void Update()
    {
        if (_currentDamageTime <= 0)
        {
            _canDamage = true;
        }
        else
        {
            _canDamage = false;
            _currentDamageTime -= Time.deltaTime;
        }

        var dist = range;
        var hits = RaycastEntities();

        // Selects hits that match specific layer values (7, 15, 16, or 19) and then finds the minimum distance from those hits to the transform's position
        // The final minimum distance is stored in the variable dist
        dist = hits.Where(hit => hit.collider != null && hit.collider.gameObject.layer is 7 or 15 or 16 or 19)
            .Aggregate(dist, (current, hit) => Mathf.Min(current, (hit.point - transform.position).magnitude));

        Resize(dist);
        Rotate();
    }

    protected override RaycastHit[] RaycastEntities()
    {
        var transform1 = transform;
        var hits = Physics.RaycastAll(transform1.position, transform1.forward, range);

        Array.Sort(hits, (x, y) => x.distance.CompareTo(y.distance));

        var wallHitDetected = false;
        var hitList = new List<RaycastHit>();  // Create a list to store valid hits

        foreach (var t in hits)
        {
            if (bulletData.destroyMask == (bulletData.destroyMask | (1 << t.collider.gameObject.layer)))
            {
                Instantiate(bulletData.deathParticles, t.point, Quaternion.LookRotation(-transform.forward, Vector3.up));

                switch (t.collider.gameObject.layer)
                {
                    // Wall, Enemy Shield, Player Shield, Player Shield No Wall
                    case 7:
                    case 15:
                    case 16:
                    case 19:
                        wallHitDetected = true;
                        break;

                    // Enemy, Player
                    case 8:
                    case 9:
                        var entity = t.collider.GetComponent<Entity>();

                        if (entity != null && _canDamage)
                        {
                            MakeDamage(entity);
                            _currentDamageTime = damageTime;
                        }
                        break;

                    // Submodule
                    case 6:
                        if (_canDamage)
                        {
                            MakeDamage(t.collider.GetComponent<BossSubmodule>());
                            _currentDamageTime = damageTime;
                        }
                        break;
                }
            }
            else
            {
                // Add non-wall hits to the hitList
                hitList.Add(t);
            }
        }

        // Convert the hitList to an array
        var finalHits = hitList.ToArray();

        return wallHitDetected ? finalHits : // Return the hitList as it is if wall hit is detected
            hits; // Return the original hits array
    }

    private void Resize(float dist)
    {
        transform.localScale = new Vector3(transform.localScale.x, transform.localScale.y, dist);
    }
    
    private void Rotate()
    {
        const float rotationSpeed = 100f;
        transform.Rotate(0, 0, rotationSpeed * Time.deltaTime);
    }

    public void SetParams(float dur, int submoduleIndex)
    {
        duration = dur;
        _submoduleIndex = submoduleIndex;
    }

    private void OnDestroy()
    {
        // It's necessary to unsubscribe from the event when destroying the object
        EventManager.Instance.Unsubscribe(EventManager.NameEvent.OnStunnedSubmodule, OnSubmoduleStunned);
    }

    /// <summary>
    /// Destroy the laser beam when the submodule is stunned
    /// </summary>
    /// <param name="parameters"></param>
    private void OnSubmoduleStunned(params object[] parameters)
    {
        if (parameters[0] is int index && index == _submoduleIndex)
            Destroy(gameObject);
    }
}
