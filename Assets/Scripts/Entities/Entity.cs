using System.Collections;
using System.Linq;
using MM.Entities.Player.Arms;
using UnityEngine;

namespace MM.Entities
{
    public abstract class Entity : MonoBehaviour, IDamageable<float, PlayerArm.ArmType, bool>
    {
        #region Private Variables
        [Header("Entity Parameters")]
        [SerializeField] protected float hp;
        [SerializeField] protected float movementSpeed;
        [SerializeField] protected float rotationSpeed;

        protected float _currentHp;

        //On Damaged VFX. 
        protected Renderer[] allRenderers;
        protected Material[] baseMats;
        protected Material damagedMat;
    
        private ParticleSystemForceField _forceField;
        #endregion

        #region Monobehaviour Functions
        protected virtual void Awake()
        {
            _currentHp = hp;
        
            // Get all renderers that are not of type LineRenderer
            allRenderers = GetComponentsInChildren<Renderer>().Where(x => x.GetType() != typeof(LineRenderer) && x.GetType() != typeof(ParticleSystemRenderer)).ToArray();
        
            baseMats = new Material[allRenderers.Length];
            for (var i = 0; i < allRenderers.Length; i++)
            {
                baseMats[i] = new Material(allRenderers[i].material);
            }

            damagedMat = new Material(Shader.Find("Unlit/Color"))
            {
                color = Color.white
            };
        }
        #endregion

        #region Public Functions
        public virtual void TakeDamage(float damage, PlayerArm.ArmType aType = PlayerArm.ArmType.None, bool showDamage = true)
        {
            _currentHp -= damage;
        
            if (showDamage)
                StartCoroutine(ShowDamage());
        
            if (_currentHp <= 0)
                KillEntity();
        }
        
        public virtual void KillEntity()
        {
            Destroy(gameObject);
        }
    
        /// <summary>
        /// Get the particle system force field component for the merge / hacking effect
        /// </summary>
        /// <returns></returns>
        public ParticleSystemForceField GetParticleForceField()
        {
            if (_forceField == null)
                _forceField = GetComponentInChildren<ParticleSystemForceField>();
        
            return _forceField;
        }
        
        public float GetMovementSpeed()
        {
            return movementSpeed;
        }
        
        public float GetRotationSpeed()
        {
            return rotationSpeed;
        }
        
        public float GetHp()
        {
            return hp;
        }
        #endregion

        #region Private Functions
        protected virtual IEnumerator ShowDamage()
        {
            var renderers = allRenderers.Where(x => x != null).ToArray();
            foreach (var item in renderers)
                item.material = damagedMat;

            const float timer = 0.15f;
            yield return new WaitForSeconds(timer);

            RestoreToOriginalMaterials();
        }
    
        /// <summary>
        /// Restores the original materials for a set of renderers.
        /// </summary>
        protected void RestoreToOriginalMaterials()
        {
            for (var i = 0; i < allRenderers.Length; i++)
            {
                if (allRenderers[i] == null)
                    continue;
            
                allRenderers[i].material = baseMats[i];
            }
        }
        #endregion
    }
}
