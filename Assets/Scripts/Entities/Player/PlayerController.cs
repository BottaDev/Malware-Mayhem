using System;
using System.Collections;
using System.Linq;
using UnityEngine;

public class PlayerController : MonoBehaviour
{
    public Pool<Bullet> bulletPool;
    public Pool<Bullet> assaultBulletPool;
    public Pool<Bullet> shieldBulletPool;

    private const float _pullDown = 0.1f; // dimensionless > 0, < 1
    private float _horizontalMovement;
    private float _verticalMovement;
    private float _currentSpeed;
    private float _maxOverSpeed;
    private float _percentage;
    private int _submoduleIndex;
    private bool _leftArmToChange = true;
    private bool _isAbsorbing;
    private bool _canTakeDamage = true;
    private bool _lowLife;
    private PlayerArm _currentLeftArm;
    private PlayerArm _currentRightArm;
    private PlayerModel _model;
    private PlayerView _view;
    private Rigidbody _rb;
    private Enemy _closeEnemy;
    private Camera _cam;
    
    private static bool IsPaused => PauseManager.Instance.isPaused;

    private void Awake()
    {
        _model = GetComponent<PlayerModel>();
        _view = GetComponent<PlayerView>();
        _rb = GetComponent<Rigidbody>();
        _cam = Camera.main;

        _maxOverSpeed = _model.movementSpeed + 1;
    }

    private void Start()
    {
        SetStartingArm();
        
        // Set HP 
        UIManager.Instance.SetMaxHealth(_model.hp);
        
        EventManager.Instance.Subscribe(EventManager.NameEvent.OnReturnedBoss, OnReturnedBoss);

        CreatePools();
    }

    private void SetStartingArm()
    {
        var armIndex = _model.startingArm switch
        {
            PlayerArm.ArmType.BasicArm => 0,
            PlayerArm.ArmType.LaserArm => 1,
            PlayerArm.ArmType.BurstArm => 2,
            PlayerArm.ArmType.ShieldArm => 3,
            PlayerArm.ArmType.BladeArm => 4,
            _ => 0
        };

        SetArm(true, armIndex);
        SetArm(false, armIndex);
    }
    
    private void CreatePools()
    {
        var poolTransform = GameObject.Find("Pool").GetComponent<Transform>();
        if (poolTransform == null)
            Debug.LogError("Pool Object not found in scene");
        
        var basicBulletFactory = new BasicBulletFactory(poolTransform);
        bulletPool = new Pool<Bullet>(basicBulletFactory.Create, Bullet.TurnOn, Bullet.TurnOff, 6);
        
        var assaultBulletFactory = new PlayerAssaultBulletFactory(poolTransform);
        assaultBulletPool = new Pool<Bullet>(assaultBulletFactory.Create, Bullet.TurnOn, Bullet.TurnOff, 6);
        
        var shieldBulletFactory = new PlayerShieldBulletFactory(poolTransform);
        shieldBulletPool = new Pool<Bullet>(shieldBulletFactory.Create, Bullet.TurnOn, Bullet.TurnOff, 1);
    }
    
    public void Update()
    {
        if(IsPaused) return;

        if (_isAbsorbing)
        {
            PauseManager.Instance.isPlayerAbsorbing = true;
            if (Vector3.Distance(transform.position, _closeEnemy.transform.position) > _model.absorbDistance || !_closeEnemy.isStunned)
                _isAbsorbing = false;

            if (Input.GetKeyDown(KeyCode.Q) || Input.GetMouseButtonDown(0))
            {
                AudioManager.Instance.Play("AbsorbEnemy");
                PlayerView.ShowAbsorptionEffect(_closeEnemy, _model.leftArmParticleForceField);
                _closeEnemy.KillEntity();
                SetArmToChange(_closeEnemy.type, true);
                _isAbsorbing = false;
            }
            else if (Input.GetKeyDown(KeyCode.E) || Input.GetMouseButtonDown(1))
            {
                AudioManager.Instance.Play("AbsorbEnemy");
                PlayerView.ShowAbsorptionEffect(_closeEnemy, _model.rightArmParticleForceField);
                _closeEnemy.KillEntity();
                SetArmToChange(_closeEnemy.type, false);
                _isAbsorbing = false;
            }
            else if (Input.GetKeyDown(KeyCode.Space))
            {
                HealPlayer(_model.healAmount);
                _closeEnemy.KillEntity();
                _isAbsorbing = false;
            }
        }
        else
        {
            PauseManager.Instance.isPlayerAbsorbing = false;
            if (Input.GetMouseButton(0) || Input.GetMouseButtonDown(0))
            {
                if (_currentLeftArm.GetDuration() <= 0)
                    ResetToBasicArm(true);
                else
                    UseArm(true);
            }

            if (Input.GetMouseButton(1) || Input.GetMouseButtonDown(1))
            {
                if (_currentRightArm.GetDuration() <= 0)
                    ResetToBasicArm(false);
                else
                    UseArm(false);
            }
            
            if (Input.GetKeyDown(KeyCode.Space))
                CheckStunnedEntity();
        }
        
        if (_isAbsorbing)
        {
            Time.timeScale = Mathf.Lerp(Time.timeScale, _model.timeScaleSlow, _model.timeScaleSpeed * Time.deltaTime);
            _cam.fieldOfView = Mathf.Lerp(_cam.fieldOfView, _model.minCamFOV, _model.camZoomSpeed * Time.deltaTime);
        }
        else
        {
            Time.timeScale = Mathf.Lerp(Time.timeScale, 1, (_model.timeScaleSpeed * 2) * Time.deltaTime);
            _cam.fieldOfView = Mathf.Lerp(_cam.fieldOfView, _model.maxCamFOV, (_model.camZoomSpeed * 2) * Time.deltaTime);
        }
    }
    
    /// <summary>
    /// Set the arm to the basic arm
    /// </summary>
    /// <param name="isLeft"></param>
    private void ResetToBasicArm(bool isLeft)
    {
        Invoke(isLeft ? nameof(ResetLeftArm) : nameof(ResetRightArm) , _model.armResetTime);
        
        PlayerView.ResetArm(isLeft ? _currentLeftArm : _currentRightArm);
    }
    
    private void ResetLeftArm()
    {
        SetArm(true, 0);
    }

    private void ResetRightArm()
    {
        SetArm(false, 0);
    }

    private void UseArm(bool left)
    {
        if (IsPaused) return;
        
        if (left)
            _currentLeftArm.MakeAction();
        else
            _currentRightArm.MakeAction();
    }
    
    /// <summary>
    /// Check if there's a submodule in the player's range to absorb
    /// </summary>
    private void CheckStunnedEntity()
    {
        var modules = Physics.OverlapSphere(transform.position, _model.absorbDistance, _model.moduleAbsorbMask)
            .Select(x => x.GetComponent<BossSubmodule>()).ToList();
        
        var closeModule = modules.Where(x=> x.GetIsStunned())
            .OrderBy(x => Vector2.Distance(transform.position, x.transform.position))
            .ToList()
            .FirstOrDefault();

        if (closeModule != null && !_isAbsorbing && !closeModule.wasAbsorbed)
        {
            closeModule.wasAbsorbed = true;
            _submoduleIndex = closeModule.submoduleIndex;
            ChangeSubmodule(_submoduleIndex);
            
            return;
        }

        CheckStunnedEnemy();
    }

    /// <summary>
    /// Check if there's a enemy in the player's range to absorb
    /// </summary>
    private void CheckStunnedEnemy()
    {
        var enemies = Physics.OverlapSphere(transform.position, _model.absorbDistance, _model.enemyAbsorbMask)
            .Select(x => x.GetComponent<Enemy>()).ToList();
        
        // Is the boss...
        if (enemies.Count == 1 && enemies.First() == null)
            return;

        _closeEnemy = enemies.Where(enemy => enemy != null && enemy.GetIsStunned())
            .OrderBy(x => Vector2.Distance(transform.position, x.transform.position))
            .ToList()
            .FirstOrDefault();

        if (_closeEnemy != null && !_isAbsorbing)
            StartCoroutine(AbsorbEnemy());
    }
    
    private IEnumerator AbsorbEnemy()
    {
        _isAbsorbing = true;
        UIManager.Instance.ToggleAbsorbMenu(true);
        
        yield return new WaitWhile(() => _isAbsorbing);

        _closeEnemy = null;
        UIManager.Instance.ToggleAbsorbMenu(false);
    }

    private void ChangeSubmodule(int lvl)
    {
        EventManager.Instance.Trigger(EventManager.NameEvent.OnAbsorbedSubmodule, lvl);
    }
	
    private void SetArm(bool isLeft, int armIndex)
    {
        UIManager.Instance.SetArmBar(isLeft, armIndex);
        
        if (isLeft)
        {
            _currentLeftArm = _model.leftArms[armIndex];
            _currentLeftArm.ResetEnergy();
            PlayerView.ShowArm(_model.leftArms, armIndex);
        }
        else
        {
            _currentRightArm = _model.rightArms[armIndex];
            _currentRightArm.ResetEnergy();
            PlayerView.ShowArm(_model.rightArms, armIndex);
        }
        
        EventManager.Instance.Trigger(EventManager.NameEvent.OnArmChanged);
    }
    
    /// <summary>
    /// Set the arm to change when the player absorb an enemy
    /// </summary>
    /// <param name="type"></param>
    /// <param name="isLeftArm"></param>
    private void SetArmToChange(Enemy.EnemyType type, bool isLeftArm)
    {
        var armIndex = GetArmSetIndex(type);

        SetArm(isLeftArm, armIndex);
    }
    
    private static int GetArmSetIndex(Enemy.EnemyType type)
    {
        return type switch
        {
            Enemy.EnemyType.LaserPorter => 1,
            Enemy.EnemyType.AssaultBox => 2,
            Enemy.EnemyType.Shielder => 3,
            Enemy.EnemyType.Blader => 4,
            _ => 0
        };
    }
    
    public void FixedUpdate()
    {
        Move();
        RotateTorso();
    }
    
    private void Move()
    {
        _horizontalMovement = Input.GetAxisRaw("Horizontal");
        _verticalMovement = Input.GetAxisRaw("Vertical");

        var movementDirection = new Vector3(_horizontalMovement, 0, _verticalMovement);

        Accelerate(movementDirection.normalized);
        
        if (movementDirection == Vector3.zero)
            _currentSpeed = 0;

        //_view.ShowDustVfx(_horizontalMovement, _verticalMovement);
        
        RotateLegs(movementDirection);
    }
    
    private void Accelerate(Vector3 dir)
    {
        if (_currentSpeed < _model.movementSpeed)
            _currentSpeed += _model.acceleration;

        // Clamp max over speed
        _currentSpeed = _currentSpeed > _maxOverSpeed ? _maxOverSpeed : _currentSpeed;

        var speedAdjust = _currentSpeed - _model.movementSpeed;

        // Pull speed down if needed
        _currentSpeed -= speedAdjust > 0.0f ? speedAdjust * _pullDown : 0.0f;

        // Set the velocity magnitude to the new speed
        _rb.velocity = dir * _currentSpeed;
    }

    private void RotateLegs(Vector3 movementDirection)
    {
        if (movementDirection == Vector3.zero) 
            return;
        
        var toRotation = Quaternion.LookRotation(movementDirection, Vector3.up);
        _model.legs.transform.rotation = Quaternion.RotateTowards(_model.legs.transform.rotation, toRotation, (_model.rotationSpeed * 10) * Time.deltaTime);
    }
    
    private void RotateTorso()
    {
        var position = _model.torso.transform.position;
        var forward = _model.torso.transform.forward;
        
        var targetDelta = (new Vector3(InputManager.Instance.mousePosition.x, position.y, InputManager.Instance.mousePosition.z) - position).normalized;
        var angleToTarget = Vector3.Angle(forward, targetDelta);
        var turnAxis = Vector3.Cross(forward, targetDelta);

        _model.torso.transform.RotateAround(transform.position, turnAxis, Time.fixedDeltaTime * Mathf.Pow(2, _model.torsoSpeed) * angleToTarget);
        
        // Make sure torso only rotates in Y axis
        var rotation = _model.torso.transform.rotation;
        rotation = new Quaternion(0, rotation.y,0, rotation.w);
        _model.torso.transform.rotation = rotation;
    }
    
    private void OnCollisionExit(Collision other)
    {
        // Enemy
        if (other.gameObject.layer == 8)
            _rb.velocity = Vector3.zero;
    }

    public void TakeDamage(float damage)
    {
        if (!_canTakeDamage)
            return;
        
        _model.SetCurrentHealth(_model.GetCurrentHealth() - damage);
        
        AudioManager.Instance.Play("PlayerDamaged");
        UIManager.Instance.SetHealth(_model.GetCurrentHealth(), true);
        
        _percentage = (_model.GetCurrentHealth() / _model.hp) * 100;
        if (_percentage <= 40 && !_lowLife)
        {
            EventManager.Instance.Trigger(EventManager.NameEvent.OnLowLife, true);
            _lowLife = true;
        }

        if (!(_model.GetCurrentHealth() <= 0)) 
            return;

        if (BossManager.Instance.CheckFightSubmodule())
        {
            EventManager.Instance.Trigger(EventManager.NameEvent.OnReturnedBoss, false, _submoduleIndex);
            Destroy(gameObject);
            return;
        }
        
        var t = transform;
        Instantiate(_model.corpsePrefab, t.position, Quaternion.LookRotation(t.forward, t.up));
        Instantiate(_model.deathParticles, transform.position + Vector3.up * .5f, Quaternion.identity);
        _model.KillEntity();
    }
    
    public void HealPlayer(float amount)
    {
        _model.SetCurrentHealth(_model.GetCurrentHealth() + amount);

        if (_model.GetCurrentHealth() > _model.hp)
            _model.SetCurrentHealth(_model.hp);
        
        _percentage = (_model.GetCurrentHealth() / _model.hp) * 100;
        if (_percentage > 40 && _lowLife)
        {
            EventManager.Instance.Trigger(EventManager.NameEvent.OnLowLife, false);
            _lowLife = false;
        }
        
        UIManager.Instance.SetHealth(_model.GetCurrentHealth(), false);
    }

    public bool GetIfLowLife()
    {
        return _lowLife;
    }
    
    private void ResetPlayerMovement()
    {
        _horizontalMovement = 0;
        _verticalMovement = 0;
        
        _rb.velocity = Vector3.zero;
    }
    
    private void OnReturnedBoss(params object[] parameters)
    {
        if(this == null) 
            return;
        
        const float time = 0.2f;
        Invoke(nameof(ResetPlayerMovement), time);
        
        ReturnBarsValues();
    }
    
    /// <summary>
    /// Set the current values of the ui bars when the player
    /// return to the main boss fight
    /// </summary>
    private void ReturnBarsValues()
    {
        // Make sure the active player set the current bars values
        if (!gameObject.activeInHierarchy)
            return;
        
        var leftIndex = _model.leftArms.IndexOf(_currentLeftArm);
        var rightIndex = _model.rightArms.IndexOf(_currentRightArm);
        
        UIManager.Instance.SetArmBar(true, leftIndex);
        UIManager.Instance.SetArmBar(false, rightIndex);
        
        _currentLeftArm.ForceUIBarValue();
        _currentRightArm.ForceUIBarValue();
        
        UIManager.Instance.SetHealth(_model.GetCurrentHealth(), false);
    }

    public Tuple<PlayerArm, PlayerArm> GetCurrentArmsType()
    {
        return new Tuple<PlayerArm, PlayerArm>(_currentLeftArm, _currentRightArm);
    }
}
