using System.Collections;
using EZCameraShake;
using UnityEngine;
using UnityEngine.AI;
using Random = UnityEngine.Random;

[RequireComponent(typeof(FOV))]
public abstract class Enemy : Entity, IUpdatable
{
    [Header("Enemy Parameters")]
    public EnemyType type;
    [SerializeField, Range(0, 100)] private float stunPercentageChance = 50f;
    [SerializeField] private float stunTime = 5f;
    [Tooltip("The percentage that the enemy recovers when leaving the stun state")]
    [SerializeField, Range(1, 100)] private float recoveryPercentage = 30f;

    [Space,Header("Camera Shake")] 
    [Tooltip("The intensity of the shake.")]
    [SerializeField, Range(1f,10f)] protected float magnitude;
    [Tooltip("How rough the shake is. Lower values are slow and smooth, higher values are fast and jarring")]
    [SerializeField, Range(1f,20f)] protected float roughness;
    [Tooltip("The time, in seconds, for the shake to fade in")]
    [SerializeField, Range(1f,10f)] protected float fadeIn;
    [Tooltip("The time, in seconds, for the shake to fade out")]
    [SerializeField, Range(1f,10f)] protected float fadeOut;

    protected PlayerModel _player;
    protected NavMeshAgent _agent;
    protected CameraShaker _cameraShaker;
    protected float _distanceToPlayer;
    protected float _currentMovementSpeed;
    
    public bool isStunned;
    private  bool _isDead;
    private bool _isInvulnerable;
    private bool _wasStunned;
    private Rigidbody _rb;
    protected FOV _fov;

    [Space(15)]
    [SerializeField] protected GameObject corpsePrefab;
    [SerializeField] protected GameObject deathParticles;
    [SerializeField] protected GameObject stunnedParticles;
    [SerializeField] protected GameObject onStunParticles;
    public AbsortionParticles absortionParticles;
    [SerializeField] protected GameObject absorbImg;
    [SerializeField] protected Material[] stunnedMaterials;

    protected override void Awake()
    {
        base.Awake();
        
        _agent = GetComponent<NavMeshAgent>();
        _rb = GetComponent<Rigidbody>();
        _fov = GetComponent <FOV>();
        _cameraShaker = Camera.main.GetComponent<CameraShaker>();
        absorbImg.SetActive(false);
        _currentMovementSpeed = movementSpeed;
    }
    
    private void Start()
    {
        EventManager.Instance.Subscribe("OnAbsorbedSubmodule", OnAbsorbedSubmodule);
    }

    private void OnEnable()
    {
        UpdateManager.Instance.updates.Add(this);
    }

    private void OnDisable()
    {
        UpdateManager.Instance.updates.Remove(this);
    }

    public virtual void FalseUpdate()
    {
        if (CheckPlayer())
            return;
        
        SetAISpeed();

        _distanceToPlayer = Vector3.Distance(transform.position, _player.transform.position);

        if (!isStunned)
        {
            Move();
            MakeActions();   
        }
    }

    /// <summary>
    /// Check if the player exists in the level
    /// </summary>
    /// <returns></returns>
    private bool CheckPlayer()
    {
        if (_player == null)
            _player = LevelManager.Instance.GetPlayer();

        return _player == null;
    }
    
    private void SetAISpeed()
    {
        _agent.speed = _currentMovementSpeed;
    }

    protected virtual void RotateTowards (Vector3 target) 
    {
        Vector3 direction = (target - transform.position).normalized;
        Quaternion lookRotation = Quaternion.LookRotation(new Vector3(direction.x, 0, direction.z));
        transform.rotation = Quaternion.Slerp(transform.rotation, lookRotation, Time.deltaTime * rotationSpeed);
    }
    
    protected void MoveToPosition(Vector3 position)
    {
        if(_agent.destination == Vector3.positiveInfinity)
            _agent.destination = position;
    }
    
    protected virtual void Move() { }
    
    protected virtual void MakeActions() { }

    private void OnCollisionExit(Collision other)
    {
        // Enemy, Player
        if (other.gameObject.layer is 8 or 9)
            _rb.velocity = Vector3.zero;
    }

    public override void TakeDamage(float damage, Bullet.BulletType bType = Bullet.BulletType.None, bool showDamage = true)
    {
        if (_isInvulnerable)
            return;
     
        if(showDamage)
            StartCoroutine(ShowDamage());
        
        _currentHp -= damage;
        AudioManager.Instance.Play("EnemyDamaged");

        if (_currentHp <= 0 && !_wasStunned && (Random.value < stunPercentageChance * 0.01f))
        {
            StartCoroutine(StunEnemy());   
        }
        else if (_currentHp <= 0 && !_isDead)
        {
            Instantiate(corpsePrefab, transform.position, Quaternion.LookRotation(transform.forward, transform.up));
            Instantiate(deathParticles, transform.position + Vector3.up * .5f, Quaternion.identity);
            KillEntity();
        }
    }

    protected virtual IEnumerator StunEnemy()
    {
        _isInvulnerable = true;
        absorbImg.gameObject.SetActive(true);
        _wasStunned = true;
        isStunned = true;
        _currentMovementSpeed = 0;
        
        if (_agent.enabled)
            _agent.isStopped = true;

        const float resetTime = 1f;
        Invoke(nameof(ResetInvulnerability), resetTime);
        
        Instantiate(onStunParticles, transform.position, Quaternion.identity);
        var ps = Instantiate(stunnedParticles, transform);
        ps.transform.localPosition = transform.up;
        
        yield return new WaitForSeconds(stunTime);

        for (var i = 0; i < allRenderers.Length; i++)
            allRenderers[i].material = baseMats[i];
        
        Destroy(ps);
        absorbImg.gameObject.SetActive(false);

        if(_agent.enabled == true)
            _agent.isStopped = false;
        isStunned = false;
        
        RecoverFromStun();
    }

    protected virtual void RecoverFromStun()
    {
        ResetMovementSpeed();
        
        float newHp = (recoveryPercentage * hp) / 100;
        _currentHp = newHp;
    }
    
    private void ResetInvulnerability()
    {
        _isInvulnerable = false;
    }
    
    public override void KillEntity()
    {
        _cameraShaker.ShakeOnce(magnitude, roughness, fadeIn, fadeOut);
        _isDead = true;
        EventManager.Instance.Trigger("OnEnemyDead", type);
        AudioManager.Instance.Play("EnemyDead");
        base.KillEntity();
    }

    protected override IEnumerator ShowDamage()
    {
        foreach (var item in allRenderers)
            item.material = damagedMat;

        yield return new WaitForSeconds(.1f);

        for (int i = 0; i < allRenderers.Length; i++)
            allRenderers[i].material = isStunned ? stunnedMaterials[i] : baseMats[i];
    }
    
    public bool GetIsStunned()
    {
        return isStunned;
    }

    public FOV GetFov()
    {
        return _fov;
    }

    private void ResetMovementSpeed()
    {
        _currentMovementSpeed = movementSpeed;
    }
    
    private void OnAbsorbedSubmodule(params object[] parameters)
    {
        if (this != null)
            KillEntity();
    }
    
    public enum EnemyType
    {
        LaserPorter,
        AssaultBox,
        Shielder,
        Blader
    }
}
