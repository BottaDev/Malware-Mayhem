using System.Collections;
using MM.Common;
using UnityEngine;
using UnityEngine.AI;

namespace MM.Entities.Enemies.Bosses.Iset.SubModuleBosses
{
    public class GunSubBoss : SubBoss
    {
        #region Private Variables
        
        [SerializeField] private float attackDistance;
        [SerializeField] private Transform shotSpawn;
        [SerializeField] private float idealDistance;
        
        [Header("Tri-Shot Parameters")]
        [SerializeField] private int triTotalBullets;
        [SerializeField] private float timeBetweenShot = 5;
        [SerializeField] private float triAttackPush;
        [SerializeField] private float timeBeforeTriShot;
        [SerializeField] private BossBulletType triShotBulletType;
        
        [Header("Forward Shot Parameters")]
        [SerializeField] private float forwardAttackPush;
        [SerializeField] private float timeBeforeForwardShot;
        [SerializeField] private BossBulletType forwardShotBulletType;

        private bool _canAttack;
        private bool _isAttacking;
        private bool _nextIsTriShot;
        private float _distanceToPlayer;
        private float _currentFireRate;
        private FOV _fov;
        private NavMeshAgent _agent;
        private Rigidbody _rigidbody;
        private Transform _t;
        private Vector3 _moveDirection;
        private Animator _animator;
        
        private static readonly int IsMoving = Animator.StringToHash("IsMoving");

        #endregion

        #region MonoBehaviour Functions

        protected override void Awake()
        {
            base.Awake();

            _agent = GetComponent<NavMeshAgent>();
            _fov = GetComponent<FOV>();
            _rigidbody = GetComponent<Rigidbody>();
            _t = transform;
            _animator = GetComponentInChildren<Animator>();
            
            var firstAttack = Random.Range(0, 2);
            _currentFireRate = firstAttack == 0 ? timeBeforeTriShot : timeBeforeForwardShot;
        }

        private void Update()
        {
            if(_player == null) { return; }
            
            _distanceToPlayer = Vector3.Distance(_t.position, _player.transform.position);
            
            Move();
            
            switch (_canAttack)
            {
                case true:
                    ChooseAttack();
                    break;
                case false when !_isAttacking:
                {
                    _currentFireRate -= Time.deltaTime;
                    if (_currentFireRate <= 0)
                    {
                        _canAttack = true;
                    }

                    break;
                }
            }
        }

        #endregion

        #region Private Functions

        /// <summary>
        /// Choose between tri-shot or forward shot and set the current fire rate.
        /// </summary>
        private void ChooseAttack()
        {
            if (_nextIsTriShot)
            {
                StartCoroutine(nameof(MakeTriShot));
                _currentFireRate = timeBeforeForwardShot;
            }
            else
            {
                MakeForwardShot();
                _currentFireRate = timeBeforeTriShot;
            }
        }
        
        private IEnumerator MakeTriShot()
        {
            _canAttack = false;
            _isAttacking = true;
            _nextIsTriShot = false;

            for (var i = 0; i < triTotalBullets; i++)
            {
                var position = shotSpawn.position;
                
                var bullet = EnemyPoolManager.Instance.GetBossBullet(triShotBulletType);
                
                var bulletTransform = bullet.transform;
                
                bulletTransform.position = position;
                bulletTransform.eulerAngles = _t.rotation.eulerAngles;
                
                _rigidbody.AddForce(-_t.forward * triAttackPush, ForceMode.Impulse);

                yield return new WaitForSeconds(timeBetweenShot);
            }
            
            _moveDirection = CalculateNextDirection();
            _isAttacking = false;
        }

        private void MakeForwardShot()
        {
            _canAttack = false;
            _isAttacking = true;
            _nextIsTriShot = true;
            
            var position = shotSpawn.position;
            
            var bullet = EnemyPoolManager.Instance.GetBossBullet(forwardShotBulletType);
            
            var bulletTransform = bullet.transform;
            bulletTransform.position = position;
            bulletTransform.eulerAngles = _t.rotation.eulerAngles;
            
            _rigidbody.AddForce(-_t.forward * forwardAttackPush, ForceMode.Impulse);

            _moveDirection = CalculateNextDirection();
            _isAttacking = false;
            
            StartCoroutine(nameof(StopRigidbodyVelocity));
        }
        
        private void Move()
        {
            if (_isAttacking)
            {
                _animator.SetBool(IsMoving, false);
                StayIdle();
                return;
            }
            
            _animator.SetBool(IsMoving, true);
            if (_distanceToPlayer >= attackDistance || _fov.CheckMiddleObstacle(_player.transform.position))
            {
                MoveToPosition(_player.transform.position);
            }
            else
            {
                MoveToPosition(_t.position + _moveDirection);
            }

            RotateTowards(_t.position + _moveDirection);
            RotateBody(_player.transform.position);
        }

        private void MoveToPosition(Vector3 position)
        {
            if (_agent.destination == Vector3.positiveInfinity) { return; }

            _agent.destination = position;
        }
        
        private void RotateTowards (Vector3 target) 
        {
            var direction = (target - transform.position).normalized;
            var lookRotation = Quaternion.LookRotation(new Vector3(direction.x, 0, direction.z));
            _t.rotation = Quaternion.Slerp(_t.rotation, lookRotation, Time.deltaTime * rotationSpeed);
        }
        
        private Vector3 CalculateNextDirection()
        {
            var newPos = _t.position;
        
            if (_player != null)
            {
                newPos = _player.transform.position;
            }
        
            if (_agent.enabled)
            {
                _agent.isStopped = false;
            }
        
            var nextDir = (_distanceToPlayer >= idealDistance ? newPos - _t.position : 
                                                                       _t.position - newPos).normalized;

            return nextDir;
        }
        
        private void StayIdle()
        {
            if (_agent.enabled)
            {
                _agent.isStopped = true;
            }

            var position = _player.transform.position;
            RotateTowards(position);
            RotateBody(position);
        }
        
        /// <summary>
        /// Rotate the body to the player
        /// </summary>
        private void RotateBody(Vector3 target)
        {
            var direction = (target - _t.position).normalized;
            var lookRotation = Quaternion.LookRotation(new Vector3(direction.x, 0, direction.z));
            _t.rotation = Quaternion.Slerp(_t.rotation, lookRotation, Time.deltaTime * 12);
        }
        
        private IEnumerator StopRigidbodyVelocity()
        {
            yield return new WaitForSeconds(0.9f);
            _rigidbody.velocity = Vector3.zero;
        }

        #endregion
    }
}