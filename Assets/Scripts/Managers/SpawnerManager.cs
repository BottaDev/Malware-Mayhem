using System;
using System.Collections.Generic;
using System.Linq;
using MM.Entities;
using MM.Entities.Enemies;
using UnityEngine;
using Random = UnityEngine.Random;
using MM.Events;

namespace MM.Gameplay
{
    [Serializable]
    public class SpawnerManager : MonoBehaviour
    {
        #region Public Variables

        public List<SpawnData> enemies;
        public List<SpawnPointData> spawnPoints;
        [Header("Count Restriction")] public int maxLivingEnemies;
        public int maxSpawnedEnemies;
        [Header("Time Restriction")] public float spawnRate;
        [Header("Layers")] public LayerMask spawnObstacleMask;
        public LayerMask playerMask;

        #endregion

        #region Private Variables

        private bool _stopSpawn = true;
        private float _currentSpawnRate;
        private int _currentEnemyCount;
        private int _currentSpawnedEnemies;

        [Tooltip("0 - LaserPorter, 1 - AssaultBox, 2 - Shielder, 3 - Blader")]
        private int[] _currentSpawnCount = { 0, 0, 0, 0 };

        #endregion

        #region MonoBehaviour Functions

        private void Start()
        {
            EventManager.Instance.Subscribe(NameEvent.OnEnemyDead, OnEnemyDead);
            EventManager.Instance.Subscribe(NameEvent.OnEnemySpawn, OnEnemySpawn);
            EventManager.Instance.Subscribe(NameEvent.OnInitialAttackWait, OnInitialAttackWait);
        }

        public void Update()
        {
            if (_stopSpawn ||
                _currentEnemyCount >= maxLivingEnemies ||
                _currentSpawnedEnemies >= maxSpawnedEnemies)
            {
                return;
            }

            TryToSpawn();
        }

        private void OnDrawGizmosSelected()
        {
            foreach (var point in spawnPoints)
            {
                if (point.spawnPoint == null)
                    continue;

                var position = point.spawnPoint.position;

                Gizmos.color = Color.magenta;
                Gizmos.DrawWireSphere(position, point.spawnArea);
                Gizmos.color = Color.yellow;
                Gizmos.DrawWireSphere(position, point.detectionArea);
            }
        }

        #endregion

        #region Private Functions

        private void TryToSpawn()
        {
            if (_currentSpawnRate <= 0)
            {
                var enemy = GetEnemy();

                if (enemy == null)
                {
                    return;
                }

                var spawnPoint = GetSpawnPoint();

                SpawnEnemy(spawnPoint, enemy);
            }
            else
            {
                _currentSpawnRate -= Time.deltaTime;
            }
        }

        private SpawnPointData GetSpawnPoint()
        {
            if (spawnPoints.Count == 0)
            {
                return null;
            }

            // In each spawn point, check if the player is inside the spawn and detection area.
            // If it's inside of the detection area, but not the spawn area, add it to the list of possible spawn points.
            var pos = (from point in spawnPoints
                let position = point.spawnPoint.transform.position
                let
                    spawnAreaCollision = Physics.OverlapSphere(position, point.spawnArea, playerMask)
                let
                    detectionAreaCollision = Physics.OverlapSphere(position, point.detectionArea, playerMask)
                let
                    inSpawnArea = spawnAreaCollision.Length > 0
                let
                    inDetectionArea = detectionAreaCollision.Length > 0
                where inDetectionArea && !inSpawnArea
                select point).ToList();

            // Return random spawn point if player is not in any detection area
            return pos.Count == 0 ? spawnPoints[Random.Range(0, spawnPoints.Count)] : pos[Random.Range(0, pos.Count)];
        }

        private Vector3 GetRandomPosition(SpawnPointData spawnPointData)
        {
            while (true)
            {
                var randomPosition = Random.insideUnitSphere * spawnPointData.spawnArea +
                                     spawnPointData.spawnPoint.position;
                randomPosition.y = 0.1f;
                var colliders = Physics.OverlapSphere(randomPosition, 0.1f, spawnObstacleMask);

                if (colliders.Length > 0)
                {
                    continue;
                }

                return randomPosition;
            }
        }

        private void SpawnEnemy(SpawnPointData spawnPointData, SpawnData spawnData)
        {
            _currentEnemyCount++;
            _currentSpawnedEnemies++;

            var position = GetRandomPosition(spawnPointData);
            Instantiate(spawnData.enemySpawn, position, Quaternion.identity);

            _currentSpawnRate = spawnRate;
        }

        private SpawnData GetEnemy()
        {
            var enemiesToSpawn = (from enemy in enemies
                let count = enemy.enemySpawn.GetEnemyToSpawn().GetType() switch
                {
                    Enemy.EnemyType.LaserPorter => _currentSpawnCount[0],
                    Enemy.EnemyType.AssaultBox => _currentSpawnCount[1],
                    Enemy.EnemyType.Shielder => _currentSpawnCount[2],
                    Enemy.EnemyType.Blader => _currentSpawnCount[3]
                }
                where count < enemy.maxCount
                select enemy).ToList();

            var totalProbability = enemiesToSpawn.Sum(enemy => enemy.probability);

            var random = Random.Range(0, totalProbability);
            float currentProbability = 0;
            foreach (var enemy in enemiesToSpawn)
            {
                currentProbability += enemy.probability;
                if (random <= currentProbability)
                    return enemy;
            }

            return enemiesToSpawn[0];
        }

        #endregion

        #region Public Functions

        // Should be used when there's more than one spawner in the level
        public void SetCanSpawn(bool stop)
        {
            _stopSpawn = stop;
        }

        public List<SpawnPointData> GetSpawnPoints()
        {
            return spawnPoints;
        }

        public List<SpawnData> GetEnemies()
        {
            return enemies;
        }

        #endregion
        
        #region Event Functions

        private void OnEnemySpawn(params object[] parameters)
        {
            switch ((Enemy.EnemyType)parameters[0])
            {
                case Enemy.EnemyType.LaserPorter:
                    _currentSpawnCount[0]++;
                    break;
                case Enemy.EnemyType.AssaultBox:
                    _currentSpawnCount[1]++;
                    break;
                case Enemy.EnemyType.Shielder:
                    _currentSpawnCount[2]++;
                    break;
                case Enemy.EnemyType.Blader:
                    _currentSpawnCount[3]++;
                    break;
                default:
                    throw new ArgumentOutOfRangeException();
            }
        }

        private void OnEnemyDead(params object[] parameters)
        {
            switch ((Enemy.EnemyType)parameters[0])
            {
                case Enemy.EnemyType.LaserPorter:
                    _currentSpawnCount[0]--;
                    break;
                case Enemy.EnemyType.AssaultBox:
                    _currentSpawnCount[1]--;
                    break;
                case Enemy.EnemyType.Shielder:
                    _currentSpawnCount[2]--;
                    break;
                case Enemy.EnemyType.Blader:
                    _currentSpawnCount[3]--;
                    break;
            }

            _currentEnemyCount--;
        }

        private void OnInitialAttackWait(params object[] parameters)
        {
            _stopSpawn = false;
        }

        #endregion
    }

    [Serializable]
    public class SpawnData
    {
        public string name;
        public EnemySpawn enemySpawn;
        public int maxCount = 5;
        [Range(0, 1)] public float probability;
    }

    [Serializable]
    public class SpawnPointData
    {
        public string name;
        public Transform spawnPoint;
        public float detectionArea;
        public float spawnArea;
    }
}