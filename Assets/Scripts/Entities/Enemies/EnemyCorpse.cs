using System.Collections;
using UnityEngine;

namespace MM.Entities.Enemies
{
    public class EnemyCorpse : MonoBehaviour
    {
        #region Private Variables
        [SerializeField] private float burrowTime;
        [SerializeField] private float shiftTime;
        [SerializeField] private float force;
        [SerializeField] private GameObject[] parts;

        private const int _steps = 15;
        private bool _burrowing;
        private static readonly int BlendFactor = Shader.PropertyToID("_BlendFactor");
        #endregion

        #region MonoBehaviour Functions
        private void Start()
        {
            StartCoroutine(ShiftColor());
            Invoke(nameof(StartBurrow), burrowTime);
        }
    
        private void Update()
        {
            if (!_burrowing) 
                return;
        
            var allDown = true;
            foreach (var item in parts)
            {
                if (item.transform.position.y > -3)
                    allDown = false;
            }
        
            if (allDown)
                Destroy(gameObject);
        }
        #endregion

        #region Private Functions
        /// <summary>
        /// Change the color of the corpes to be the same as the ground
        /// </summary>
        /// <returns></returns>
        private IEnumerator ShiftColor()
        {
            var stepTime = shiftTime / (float)_steps;
            const float stepValue = 1 / (float)_steps;
            var acumValue = 0f;
            var mats = new Material[parts.Length];

            for (var i = 0; i < parts.Length; i++)
            {
                mats[i] = parts[i].GetComponent<MeshRenderer>().material;
                parts[i].GetComponent<Rigidbody>().AddExplosionForce(force, transform.position + transform.forward * 1f + transform.up * .5f, 5);
            }

            for (var i = 0; i < _steps; i++)
            {
                acumValue += stepValue;
                foreach (var item in mats)
                {
                    item.SetFloat(BlendFactor, acumValue);
                }
                yield return new WaitForSeconds(stepTime);
            }
        }

        private void StartBurrow()
        {
            foreach (var item in parts)
            {
                item.GetComponent<Collider>().enabled = false;
            }

            _burrowing = true;
        }
        #endregion
    }
}
