using MM.Common;
using UnityEngine;
using Random = UnityEngine.Random;

namespace MM.Entities.Enemies.Bosses.Iset
{
    public class IsetHookIn : SubmoduleAttack
    {
        #region Private Variables
        [SerializeField] private float hookDamage = 10f;
        [SerializeField] private float timeBeforeHook = 1.5f;
        [Tooltip("The distance that the boss must reach to shoot all the bullets")]
        [SerializeField] private float hookDistance = 1f;
            
        [SerializeField] private BossBulletType typeOfBulletToDivide;
        [SerializeField] private int numberOfBulletsToDivide = 20;
        [SerializeField, Range(0f, 360f)] private float maxAngle = 360;
        [SerializeField, Range(0f, 360f)] private float minAngle = 0;
        
        private IsetMobilizer _mobilizer;
        private BossArm _arm;
        private Vector3 _hookPos;
        private bool _hookShot;
        #endregion
        
        #region MonoBehaviour Functions
        protected override void Start()
        {
            base.Start();
            _mobilizer = GetComponentInParent<IsetMobilizer>();
            _arm = GetComponentInChildren<BossArm>();
        }
        private void Update()
        {
            var distance = Vector3.Distance(transform.position, _hookPos);
            
            if (_hookShot && distance <= hookDistance)
            {
                _hookShot = false;
                _arm.SetLookAtObject(false);
                
                SpawnBullets();
            }
        }
        #endregion
        
        #region Prviate Functions
        /// <summary>
        /// Spanws the bullets in a circle around the boss
        /// </summary>
        private void SpawnBullets()
        {
            var angleRange = maxAngle - minAngle;
            var angleStep = angleRange / numberOfBulletsToDivide;

            for (var i = 0; i < numberOfBulletsToDivide; i++)
            {
                var currentAngle = minAngle + i * angleStep + Random.Range(0f, 360f);
                var rotation = Quaternion.AngleAxis(currentAngle, Vector3.up);

                var direction = rotation * Vector3.forward;
                var position = transform.position + direction;

                // Fix the Y of the spawn
                const float yAxis = 1f;
            
                position = new Vector3(position.x, yAxis, position.z);

                var bullet = EnemyPoolManager.Instance.GetBossBullet(typeOfBulletToDivide);

                var bulletTransform = bullet.transform;
                bulletTransform.position = position;
                bulletTransform.rotation = rotation;
            }
            
            // Restore the normal movement
            _mobilizer.SetCanFlee(true);
        }

        private void ShootHook()
        {
            _mobilizer.SetCanFlee(false);
            
            if (!Physics.Raycast(transform.position, transform.forward, out var hit)) 
                return;
            
            var hook = new GameObject("HookPos")
            {
                transform =
                {
                    position = hit.point,
                    rotation = Quaternion.identity
                }
            };
                
            _arm.SetLookAtObject(hook);
            _hookShot = true;
            _hookPos = hook.transform.position;
            
            _mobilizer.MoveToHook(hook.transform.position);
        }
        #endregion
        
        #region Public Functions
        public override void MakeAction()
        {
            base.MakeAction();
            
            _arm.SetLookAtObject(true);
            
            Invoke(nameof(ShootHook), timeBeforeHook);
        }
        #endregion
    }
}
