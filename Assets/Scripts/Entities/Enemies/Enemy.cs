using System.Collections;
using EZCameraShake;
using UnityEngine;
using UnityEngine.AI;
using Random = UnityEngine.Random;

[RequireComponent(typeof(FOV))]
public abstract class Enemy : Entity
{
    [Header("Enemy Parameters")]
    public EnemyType type;
    [SerializeField, Range(0, 100)] private float stunPercentageChance = 50f;
    [SerializeField] private float stunTime = 5f;
    [Tooltip("The percentage that the enemy recovers when leaving the stun state")]
    [SerializeField, Range(1, 100)] private float recoveryPercentage = 30f;

    [Space,Header("Camera Shake")] 
    [Tooltip("The intensity of the shake.")]
    [SerializeField, Range(1f,10f)] protected float magnitude;
    [Tooltip("How rough the shake is. Lower values are slow and smooth, higher values are fast and jarring")]
    [SerializeField, Range(1f,20f)] protected float roughness;
    [Tooltip("The time, in seconds, for the shake to fade in")]
    [SerializeField, Range(1f,10f)] protected float fadeIn;
    [Tooltip("The time, in seconds, for the shake to fade out")]
    [SerializeField, Range(1f,10f)] protected float fadeOut;

    protected PlayerModel _player;
    protected NavMeshAgent _agent;
    protected float _distanceToPlayer;
    protected float _currentMovementSpeed;
    
    public bool isStunned;
    private  bool _isDead;
    private bool _isInvulnerable;
    private bool _wasStunned;
    private Rigidbody _rb;
    protected FOV _fov;

    [Space(15)]
    public GameObject corpsePrefab;
    public GameObject deathParticles;
    public GameObject stunnedParticles;
    public GameObject onStunParticles;
    public AbsortionParticles absortionParticles;
    [SerializeField] protected GameObject absorbImg;
    public Material[] stunnedMaterials;

    protected override void Awake()
    {
        base.Awake();
        
        _agent = GetComponent<NavMeshAgent>();
        _rb = GetComponent<Rigidbody>();
        _fov = GetComponent <FOV>();
        absorbImg.SetActive(false);
        _currentMovementSpeed = movementSpeed;
    }

    protected virtual void Update()
    {
        if (CheckPlayer())
            return;
        
        SetAISpeed();

        _distanceToPlayer = Vector3.Distance(transform.position, _player.transform.position);

        if (!isStunned)
        {
            Move();
            MakeActions();   
        }
    }

    /// <summary>
    /// Check if the player exists in the level
    /// </summary>
    /// <returns></returns>
    private bool CheckPlayer()
    {
        if (_player == null)
        {
            _player = GameObject.Find("Player")?.GetComponent<PlayerModel>();
            if (_player == null)
                _player = GameObject.Find("Player(Clone)")?.GetComponent<PlayerModel>();
        }

        return _player == null;
    }
    
    private void SetAISpeed()
    {
        _agent.speed = _currentMovementSpeed;
    }

    protected virtual void RotateTowards (Vector3 target) 
    {
        Vector3 direction = (target - transform.position).normalized;
        Quaternion lookRotation = Quaternion.LookRotation(new Vector3(direction.x, 0, direction.z));
        transform.rotation = Quaternion.Slerp(transform.rotation, lookRotation, Time.deltaTime * rotationSpeed);
    }
    
    protected void MoveToPosition(Vector3 position)
    {
        _agent.destination = position;
    }
    
    protected virtual void Move() { }
    
    protected virtual void MakeActions() { }

    private void OnCollisionExit(Collision other)
    {
        // Enemy, Player
        if (other.gameObject.layer is 8 or 9)
            _rb.velocity = Vector3.zero;
    }

    public override void TakeDamage(float damage, bool showDamage = true)
    {
        if (_isInvulnerable)
            return;
     
        if(showDamage)
            StartCoroutine(ShowDamage());
        
        _currentHp -= damage;
        AudioManager.Instance.Play("EnemyDamaged");

        if (_currentHp <= 0 && !_wasStunned && (Random.value < stunPercentageChance * 0.01f))
        {
            StartCoroutine(StunEnemy());   
        }
        else if (_currentHp <= 0 && !_isDead)
        {
            Instantiate(corpsePrefab, transform.position, Quaternion.LookRotation(transform.forward, transform.up));
            Instantiate(deathParticles, transform.position + Vector3.up * .5f, Quaternion.identity);
            KillEntity();
        }
    }

    protected virtual IEnumerator StunEnemy()
    {
        _isInvulnerable = true;
        absorbImg.gameObject.SetActive(true);
        _wasStunned = true;
        isStunned = true;
        _currentMovementSpeed = 0;
        
        if (_agent.enabled)
            _agent.isStopped = true;

        var resetTime = 1f;
        Invoke(nameof(ResetInvulnerability), resetTime);
        
        Instantiate(onStunParticles, transform.position, Quaternion.identity);
        GameObject ps = Instantiate(stunnedParticles, transform);
        ps.transform.localPosition = transform.up;
        
        yield return new WaitForSeconds(stunTime);

        for (var i = 0; i < allRenderers.Length; i++)
            allRenderers[i].material = baseMats[i];
        
        Destroy(ps);
        absorbImg.gameObject.SetActive(false);

        if(_agent.enabled == true)
            _agent.isStopped = false;
        isStunned = false;
        
        RecoverFromStun();
    }

    protected virtual void RecoverFromStun()
    {
        ResetMovementSpeed();
        
        float newHp = (recoveryPercentage * hp) / 100;
        _currentHp = newHp;
    }
    
    private void ResetInvulnerability()
    {
        _isInvulnerable = false;
    }
    
    public override void KillEntity()
    {
        CameraShaker.Instance.ShakeOnce(magnitude, roughness, fadeIn, fadeOut);
        _isDead = true;
        EventManager.Instance.Trigger("OnEnemyDead", type);
        AudioManager.Instance.Play("EnemyDead");
        base.KillEntity();
    }

    protected override IEnumerator ShowDamage()
    {
        foreach (var item in allRenderers)
            item.material = damagedMat;

        yield return new WaitForSeconds(.1f);

        for (int i = 0; i < allRenderers.Length; i++)
            allRenderers[i].material = isStunned ? stunnedMaterials[i] : baseMats[i];
    }
    
    public bool GetIsStunned()
    {
        return isStunned;
    }

    public FOV GetFov()
    {
        return _fov;
    }
    
    public void GetPush(Vector3 dir)
    {
        StartCoroutine(Push(dir));
    }

    private IEnumerator Push(Vector3 dir)
    {
        var elapsed = 0f;
        const float distance = 4f;
        
        var position = transform.position;
        var target = position + distance * dir;
        target.y = position.y;
        const float duration = 0.1f;

        _currentMovementSpeed = 0; 
        
        // Wall
        const int layer = 1 << 7;
        // Check if there's a wall in the middle of the path
        if (Physics.Raycast(transform.position, dir, out var hit, distance, layer))
            target = hit.point;

        while (elapsed < duration)
        {
            var iterTarget = Vector3.Lerp (position, target, elapsed / duration);
            transform.position = iterTarget;
            
            elapsed += Time.deltaTime;
            
            yield return new WaitForEndOfFrame();
        }
 
        // Snap there when we finish then update our state
        transform.position = target;

        // Apply slowdown debuff
        _currentMovementSpeed = movementSpeed / 2;

        var time = 1.5f;
        Invoke(nameof(ResetMovementSpeed), time);
    }

    private void ResetMovementSpeed()
    {
        _currentMovementSpeed = movementSpeed;
    }
    
    public enum EnemyType
    {
        LaserPorter,
        AssaultBox,
        Shielder,
        Blader
    }
}
