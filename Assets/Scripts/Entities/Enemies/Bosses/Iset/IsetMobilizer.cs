using MM.Entities.Player;
using MM.Gameplay;
using UnityEngine;
using UnityEngine.AI;

namespace MM.Entities.Enemies.Bosses.Iset
{
    [RequireComponent(typeof(Rigidbody))]
    public class IsetMobilizer : MonoBehaviour
    {
        #region Private Variables
        [Tooltip("The distance from the player that the boss will flee to")]
        [SerializeField] private float fleeDistance = 8f;
        [Tooltip("The distance from the boss that the wall will be detected")]
        [SerializeField] private float wallDistance = 3f;
        [Space]
        [Tooltip("The time between each new position calculation. This is to avoid calculating too many positions per frame and making the boss move with a weird pattern")]
        [SerializeField] private float goalTime = 0.2f;
    
        private NavMeshAgent _agent;
        private PlayerModel _player;
        private Entity _boss;
        private bool _stopMovement;
        private bool _isMovingToHook;
        private float _distanceToClosestWall;
        private float _goalTimer = 0f; // Timer for goal calculation
        private Rigidbody _rigidbody;
        #endregion

        #region MonoBehaviour Functions
        private void Awake()
        {
            _agent = GetComponent<NavMeshAgent>();
            _boss = GetComponent<Entity>();
            _rigidbody = GetComponent<Rigidbody>();
        }

        private void Update()
        {
            if (_boss.GetHp() <= 0 ||
                CheckPlayer() ||
                BossManager.Instance.GetAttackPause())
            {
                return;   
            }
        
            // Increment timer by time since last frame
            _goalTimer += Time.deltaTime;
            
            if(_goalTimer >= goalTime)
            {
                Move();
                // Reset timer after updating the goal
                _goalTimer = 0f;
            }
        }
        #endregion
    
        #region Private Functions
        private void Move()
        {
            if (_isMovingToHook)
                return;
            
            if (_stopMovement)
            {
                _agent.speed = 0;
                _agent.destination = transform.position;
                return;   
            }

            var position = transform.position;
            var distanceToPlayer = Vector3.Distance(position, _player.transform.position);
            
            // Stop the calculation of movement if the player is too far
            if (distanceToPlayer > fleeDistance)
                return;
            
            // Player is too close, flee...
            _agent.speed = _boss.GetMovementSpeed();
            
            var fleeDirection = position - _player.transform.position;
            var newGoal = position + fleeDirection.normalized * fleeDistance;

            // Check for walls in the flee direction
            if (Physics.Raycast(transform.position, fleeDirection, out _, wallDistance))
            {
                // If there's a wall, adjust to move sideways
                var sideDirection = Vector3.Cross(fleeDirection, Vector3.up).normalized;
                newGoal = transform.position + sideDirection * fleeDistance;

                // Check the other side if the first side has a wall too
                if (Physics.Raycast(transform.position, sideDirection, out _, wallDistance))
                {
                    sideDirection = Vector3.Cross(fleeDirection, Vector3.down).normalized;
                    newGoal = transform.position + sideDirection * fleeDistance;
                }
            }
            
            // Check if the newGoal position is valid on the NavMesh
            if(NavMesh.SamplePosition(newGoal, out var hit, fleeDistance, NavMesh.AllAreas))
            {
                _agent.SetDestination(hit.position);
            }
        }
    
        /// <summary>
        /// Check if the player exists in the level
        /// </summary>
        /// <returns></returns>
        private bool CheckPlayer()
        {
            if (_player == null)
                _player = LevelManager.Instance.GetPlayer();

            return _player == null;
        }
        #endregion
        
        #region Public Functions
        /// <summary>
        ///  Stop the default movement of the boss when the submodule attacks
        /// </summary>
        public void StopMovement()
        {
            _stopMovement = true;
        }

        /// <summary>
        /// Reset the default movement of the boss
        /// </summary>
        public void RestartMovement()
        {
            // Reset the velocity of the boss to avoid sliding
            _rigidbody.velocity = Vector3.zero;
            
            _stopMovement = false;
        }

        public void PushBack(Vector3 force)
        {
            _rigidbody.AddForce(force, ForceMode.Impulse);
        }
        
        public void MoveToHook(Vector3 position)
        {
            _agent.speed = _boss.GetMovementSpeed() * 2;
            
            if(NavMesh.SamplePosition(position, out var hit, 999f, NavMesh.AllAreas))
            {
                _agent.SetDestination(hit.position);
            }
        }
        
        public void SetMovingToHook(bool isMoving)
        {
            _isMovingToHook = isMoving;
        }
        #endregion
        
        #region Events
        private void OnDrawGizmosSelected()
        {
            var position = transform.position;
            
            Gizmos.color = Color.yellow;
            Gizmos.DrawWireSphere(position, fleeDistance);
            Gizmos.color = Color.blue;
            Gizmos.DrawWireSphere(position, wallDistance);
        }
        #endregion
    }
}
