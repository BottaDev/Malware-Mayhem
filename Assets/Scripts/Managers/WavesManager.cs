using System;
using System.Collections;
using System.Collections.Generic;
using MM.Entities.Enemies.Bosses;
using MM.Entities.Player;
using MM.Common;
using MM.UI;
using MM.Events;
using UnityEngine;
using UnityEngine.SceneManagement;
using Random = UnityEngine.Random;

namespace MM.Gameplay
{
    /// <summary>
    /// Manage the waves of the tutorial.
    /// </summary>
    public class WavesManager : MonoBehaviourSingleton<WavesManager>
    {
        #region Private Variables

        [SerializeField] private Waves[] waves;
        [SerializeField] private float timeBetweenWaves;

        private bool _waveFinished = true;
        private bool _cantStart;
        private bool _pillarsActive;
        private float _currentTime;
        private int _totalEnemies;
        private int _currentWave = -1;
        private TutorialPhases _currentPhase;
        private List<BossSubmodule> _miniPillars = new();
        private PlayerController _player;

        #endregion

        #region MonoBehaviour Functions

        private void Start()
        {
            EventManager.Instance.Subscribe(NameEvent.OnEnemyDead, OnEnemyDead);
            EventManager.Instance.Subscribe(NameEvent.OnBossSubmoduleDeath, OnBossSubmoduleDeath);
            EventManager.Instance.Subscribe(NameEvent.OnTextStarted, OnTextStarted);
            EventManager.Instance.Subscribe(NameEvent.OnTextFinished, OnTextFinished);
            EventManager.Instance.Subscribe(NameEvent.OnStunnedEnemy, OnStunnedEnemy);
            EventManager.Instance.Subscribe(NameEvent.OnAbsorbingEnemy, OnAbsorbingEnemy);
            EventManager.Instance.Subscribe(NameEvent.OnAbsorbedSubmodule, OnAbsorbedSubmodule);
            EventManager.Instance.Subscribe(NameEvent.OnPlayerSpawned, OnPlayerSpawned);

            _currentTime = timeBetweenWaves;
        }

        private void Update()
        {
            if (!_waveFinished || _currentWave >= waves.Length || _cantStart)
            {
                return;
            }

            if (_currentTime <= 0)
            {
                SetWave();
            }
            else
            {
                _currentTime -= Time.deltaTime;
            }
        }

        #endregion

        #region Private Functions

        /// <summary>
        /// Set the next wave
        /// </summary>
        private void SetWave()
        {
            _waveFinished = false;
            _currentTime = timeBetweenWaves;
            _currentWave++;
            _currentPhase = waves[_currentWave].phase;

            if (waves[_currentWave].hasText)
            {
                TextBoxManager.Instance.SetText(waves[_currentWave].texts);
            }

            if (waves[_currentWave].hasEnemies)
            {
                _totalEnemies = waves[_currentWave].totalEnemies;
            }

            switch (_currentPhase)
            {
                case TutorialPhases.MovementsPhase:
                {
                    if (waves[_currentWave].hasText)
                    {
                        TextBoxManager.Instance.StartText();
                    }
                    else
                    {
                        StartWave();
                    }
                    break;
                }

                case TutorialPhases.HealingPhase:
                {
                    StartWave();
                    break;
                }

                case TutorialPhases.ArmsPhase:
                {
                    if (_currentWave == 8)
                    {
                        EventManager.Instance.Subscribe(NameEvent.OnStunnedEnemy, OnStunnedEnemy);
                        StartWave();
                        _waveFinished = true;
                        _currentTime = 10;
                        _pillarsActive = true;
                    }
                    else
                    {
                        StartWave();
                    }
                    break;
                }

                case TutorialPhases.BossPhase:
                {
                    if (_currentWave == 11)
                    {
                        StartWave();
                        _waveFinished = true;
                        _currentTime = 2;
                    }
                    else
                    {
                        StartWave();
                    }
                    break;
                }
            }
        }

        private void StartWave()
        {
            var currentPos = 0;
            var currentEnemy = 0;

            for (var i = 0; i < _totalEnemies; i++)
            {
                // If the current position is greater than the total spawn points, reset it
                if (currentPos >= waves[_currentWave].spawnPoints.Count)
                {
                    currentPos = 0;
                }

                var position = waves[_currentWave].spawnPoints[currentPos].position;
                currentPos++;

                // If the current enemy is greater than the total enemies, reset it
                if (currentEnemy >= waves[_currentWave].enemies.Count)
                {
                    currentEnemy = 0;
                }

                var enemy = Instantiate(waves[_currentWave].enemies[currentEnemy], position, Quaternion.identity);
                if (_currentWave == 8)
                {
                    _miniPillars.Add(enemy.GetComponent<BossSubmodule>());
                }

                currentEnemy++;
            }
        }

        /// <summary>
        /// Repeat the current wave
        /// </summary>
        private void RepeatWave()
        {
            _currentTime = timeBetweenWaves;
            _waveFinished = false;

            if (waves[_currentWave].hasText)
            {
                TextBoxManager.Instance.SetText(waves[_currentWave].texts);
            }

            if (waves[_currentWave].hasEnemies)
            {
                // In some waves it's not necessary to spawn the same enemies as the first time, instead, spawn less enemies
                _totalEnemies = _currentWave is 7 or 10 or 12 ? Random.Range(1, 3) : waves[_currentWave].totalEnemies;
            }

            StartCoroutine(StartRepeatedWave());
        }

        /// <summary>
        /// This is used to wait a few seconds before starting the wave again
        /// If it's not used, the wave will start immediately after finishing
        /// </summary>
        /// <returns></returns>
        private IEnumerator StartRepeatedWave()
        {
            yield return new WaitForSeconds(_currentTime);

            StartWave();
        }
        
        private IEnumerator ChangeScene()
        {
            yield return new WaitForSeconds(1.5f);
            
            SceneManager.LoadScene("Notron");
        }

        #endregion

        #region Events Functions

        private void OnStunnedEnemy(params object[] parameters)
        {
            TextBoxManager.Instance.StartText();
            EventManager.Instance.Unsubscribe(NameEvent.OnStunnedEnemy, OnStunnedEnemy);
        }

        private void OnAbsorbingEnemy(params object[] parameters)
        {
            //In some cases a new text will appear before absorbing an enemy
            //Also, the player can't heal or change arms while absorbing an enemy depending on the phase
            switch (_currentPhase)
            {
                case TutorialPhases.HealingPhase:
                {
                    _player.SetCantHeal(false);
                    _player.SetCantChangeArm(true);
                    UIManager.Instance.SetMergingUI(false, true);

                    if (_currentWave == 6)
                    {
                        TextBoxManager.Instance.ContinueText();
                    }
                    break;
                }
                case TutorialPhases.ArmsPhase:
                {
                    _player.SetCantHeal(true);
                    _player.SetCantChangeArm(false);
                    UIManager.Instance.SetMergingUI(true, false);

                    if (_currentWave == 9)
                    {
                        TextBoxManager.Instance.ContinueText();
                    }
                    break;
                }
                default:
                    _player.SetCantHeal(false);
                    _player.SetCantChangeArm(false);
                    UIManager.Instance.SetMergingUI(true, true);
                    break;
            }
        }

        private void OnEnemyDead(params object[] parameters)
        {
            _totalEnemies--;

            if (_totalEnemies <= 0)
            {
                if (_currentWave == 7 && !_player.GetComponent<PlayerModel>().IsFullHP())
                {
                    RepeatWave();
                    return;
                }

                if (_currentWave == 10 && _pillarsActive)
                {
                    RepeatWave();
                    return;
                }

                if (_currentWave == 12)
                {
                    RepeatWave();
                    return;
                }

                _waveFinished = true;
                EventManager.Instance.Trigger(NameEvent.OnWaveFinished);
            }
        }

        private void OnTextFinished(params object[] parameters)
        {
            _cantStart = false;

            if (_currentPhase is TutorialPhases.MovementsPhase)
            {
                StartWave();
            }
        }

        private void OnTextStarted(params object[] parameters)
        {
            _cantStart = true;
        }

        private void OnPlayerSpawned(params object[] parameters)
        {
            var model = (PlayerModel)parameters[1];
            _player = model.GetComponent<PlayerController>();
        }

        private void OnBossSubmoduleDeath(params object[] parameters)
        {
            var bossSubmodule = (GameObject)parameters[0];

            _miniPillars.Remove(bossSubmodule.GetComponent<BossSubmodule>());
            if (_miniPillars.Count <= 0)
            {
                _pillarsActive = false;
            }
        }

        private void OnAbsorbedSubmodule(params object[] parameters)
        {
            StartCoroutine(ChangeScene());
        }

        #endregion
    }

    [Serializable]
    public struct Waves
    {
        public TutorialPhases phase;
        public bool hasText;
        public AllTexts[] texts;
        public bool hasEnemies;
        public List<GameObject> enemies;
        public List<Transform> spawnPoints;
        public int totalEnemies;
    }

    [Serializable]
    public struct AllTexts
    {
        public string texts;
        public bool stop;
    }

    public enum TutorialPhases
    {
        MovementsPhase,
        HealingPhase,
        ArmsPhase,
        BossPhase
    }
}