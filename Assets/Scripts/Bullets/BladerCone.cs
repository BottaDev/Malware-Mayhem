using System.Collections;
using MM.Entities.Player.Arms;
using MM.Entities;
using MM.Entities.Enemies.Bosses;
using UnityEngine;

namespace MM.Bullets
{
    /// <summary>
    /// The area of the melee attack
    /// </summary>
    public class BladerCone : MonoBehaviour
    {
        #region Private Variables
        [SerializeField] private float damage;
        [SerializeField] private LayerMask destroyMask;
        [SerializeField] private Texture[] textures;
    
        private MeshRenderer _mr;
        #endregion
    
        #region MonoBehaviour Functions
        private void Awake()
        {
            _mr = GetComponent<MeshRenderer>();
        }
        #endregion
    
        #region Events
        private void OnEnable()
        {
            StartCoroutine(Animate());
        }

        private void OnTriggerEnter(Collider other)
        {
            MakeDamage(other.gameObject);
        }
        #endregion

        #region Private Functions
        private void MakeDamage(GameObject other)
        {
            if (destroyMask != (destroyMask | (1 << other.layer))) 
                return;
        
            switch (other.layer)
            {
                // Enemy, Player
                case 8 or 9:
                    var entity = other.GetComponent<Entity>();
                
                    if (entity != null)
                        entity.TakeDamage(damage, PlayerArm.ArmType.BladeArm);
                    else
                        Debug.LogError("Entity not found on blader cone");
                    break;
            
                // Submodule
                case 6:
                    var bossSubmodule = other.GetComponent<BossSubmodule>();
                
                    if (bossSubmodule != null)
                        bossSubmodule.TakeDamage(damage, PlayerArm.ArmType.BladeArm);
                    else
                        Debug.LogError("BossSubmodule not found on blader cone");
                    break;
            }
        }

        private IEnumerator Animate()
        {
            const float duration = .25f;
            const int steps = 30;

            for (var i = 0; i < 30; i++)
            {
                var currentTexture = (int)(((float)i / (float)steps) * textures.Length);

                if(currentTexture < textures.Length)
                    _mr.material.mainTexture = textures[currentTexture];   

                yield return new WaitForSeconds( duration/steps);
            }
        }
        #endregion
    }
}
