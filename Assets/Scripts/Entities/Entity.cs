using System;
using System.Collections;
using System.Collections.Generic;
using System.Linq;
using UnityEditor;
using UnityEngine;

public abstract class Entity : MonoBehaviour, IDamageable<float, Bullet.BulletType, bool>
{
    [Header("Entity Parameters")]
    public float hp;
    public float movementSpeed;
    public float rotationSpeed;

    protected float _currentHp;

    //On Damaged VFX. 
    protected Renderer[] allRenderers;
    protected Material[] baseMats;
    protected Material damagedMat;

    protected virtual void Awake()
    {
        _currentHp = hp;
        
        // Get all renderers that are not of type LineRenderer
        allRenderers = GetComponentsInChildren<Renderer>().Where(x => x.GetType() != typeof(LineRenderer) && x.GetType() != typeof(ParticleSystemRenderer)).ToArray();
        
        baseMats = new Material[allRenderers.Length];
        for (var i = 0; i < allRenderers.Length; i++)
        {
            baseMats[i] = new Material(allRenderers[i].material);
        }

        damagedMat = new Material(Shader.Find("Unlit/Color"))
        {
            color = Color.white
        };
    }

    public virtual void TakeDamage(float damage, Bullet.BulletType bType = Bullet.BulletType.None, bool showDamage = true)
    {
        _currentHp -= damage;
        
        if (showDamage)
            StartCoroutine(ShowDamage());
        
        if (_currentHp <= 0)
            KillEntity();
    }

    protected virtual IEnumerator ShowDamage()
    {
        var renderers = allRenderers.Where(x => x != null).ToArray();
        foreach (var item in renderers)
            item.material = damagedMat;

        yield return new WaitForSeconds(.1f);

        for (var i = 0; i < allRenderers.Length; i++)
        {
            if (allRenderers[i] == null)
                continue;
            
            allRenderers[i].material = baseMats[i];
        }
    }

    public virtual void KillEntity()
    {
        Destroy(gameObject);
    }
}
