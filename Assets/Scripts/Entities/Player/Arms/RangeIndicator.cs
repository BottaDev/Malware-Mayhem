using MM.Entities.Enemies.Bosses;
using MM.Entities.Enemies;
using MM.Gameplay;
using UnityEngine;

namespace MM.Entities.Player.Arms
{
    /// <summary>
    /// Represents the range of absorption for the player
    /// </summary>
    [RequireComponent(typeof(LineRenderer))]
    public class RangeIndicator : MonoBehaviour
    {
        #region Private Variables
        [SerializeField, Range(0,50)] private int segments = 25;
        [SerializeField, Range(0.1f, 1f)] private float lineWidth = 0.5f;
        [Space]
        [SerializeField] private bool isSubmodule;
        [Space]
        [SerializeField] private Material normalMat;
        [SerializeField] private Material highlightedMat;
        
        private LineRenderer _line;
        #endregion
    
        #region Events
        private void OnEnable()
        {
            // Reset the color when the object is enabled
            if (isSubmodule)
                SetColor(false);
        }
        #endregion
    
        #region MonoBehaviour Functions
        private void Awake()
        {
            _line = GetComponent<LineRenderer>();
        }

        private void Start ()
        {
            // Check the type of the object that is using this script
            if (GetComponentInParent<BossSubmodule>())
                isSubmodule = true;
            else if (!GetComponentInParent<Enemy>())
                Debug.LogError("This object is not a child of an Enemy or BossSubmodule object. Please fix this.");

            RangeManager.Instance.AddIndicator(this, isSubmodule);
        
            DrawnCircle ();
        }
        #endregion

        #region Private Functions
        /// <summary>
        /// Creates points in a circular pattern for a LineRenderer to represent a range.
        /// </summary>
        private void DrawnCircle ()
        {
            var player = LevelManager.Instance.Player;
            
            _line.positionCount = segments + 1;
            _line.useWorldSpace = false;
            _line.widthMultiplier = lineWidth;

            var deltaTheta = 2f * Mathf.PI / segments;
            var theta = 0f;
            
            // Get the global scale of the object to ensure the correct size of the range and to
            // not differ from the other objects
            var lossyScale = transform.lossyScale;

            for (var i = 0; i < segments + 1; i++)
            {
                var x = player.GetAbsorbDistance() * Mathf.Cos(theta) / lossyScale.x;
                var z = player.GetAbsorbDistance() * Mathf.Sin(theta) / lossyScale.z;

                var pos = new Vector3(x, 0f, z);
                _line.SetPosition(i, pos);

                theta += deltaTheta;
            }
        }

        /// <summary>
        /// Set the color of the line renderer if the object is the closest one to the player
        /// </summary>
        /// <param name="closest"></param>
        public void SetColor(bool closest)
        {
            _line.material = closest ? highlightedMat : normalMat;
        }
        #endregion
    }
}
