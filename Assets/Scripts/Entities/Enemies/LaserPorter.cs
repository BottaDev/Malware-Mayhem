using System;
using System.Collections;
using System.Collections.Generic;
using Sound;
using Unity.VisualScripting;
using UnityEngine;
using UnityEngine.Rendering.PostProcessing;
using Random = UnityEngine.Random;

public class LaserPorter : Enemy
{
    [Header("LaserPorter Parameters")] 
    [SerializeField]private float minFireRate = 1f;
    [SerializeField]private float maxFireRate = 2f;
    [SerializeField]private float timeToFire;
    [SerializeField]private float teleportDistance;
    [SerializeField]private float visibilityDistance;
    [SerializeField]private LayerMask tpMaskObstacle;

    [Header("LaserPorter Objects")]
    [SerializeField]private GameObject laserPrefab;
    [SerializeField]private ParticleSystem chargeParticlesPrefab;
    [SerializeField]private ParticleSystem shootParticlesPrefab;
    [SerializeField]private ParticleSystem appearParticlesPrefab;
    [SerializeField]private ParticleSystem disappearParticlesPrefab;

    private float _fireRate;
    private float _currentFireRate;
    private GameObject _model;
    private GameObject _chargeParticlesInstance;
    private Collider _collider;
    private bool _isVisible = true;
    private bool _isCharging;
    private LineRenderer _lineRenderer;

    protected override void Awake()
    {
        base.Awake();
        
        _model = transform.GetChild(0).gameObject;
        _collider = GetComponent<Collider>();
        _fireRate = Random.Range(minFireRate, maxFireRate);
        _lineRenderer = GetComponent<LineRenderer>();
    }

    public override void Update()
    {
        base.Update();

        if (_isCharging)
            DrawAttackIndicator();
        else
            ResetAttackIndicator();

        //Test
        if (GetIsStunned())
        {
            CancelInvoke(nameof(Attack));
            if (_chargeParticlesInstance)
                Destroy(_chargeParticlesInstance);
        }
    }

    protected override void MakeActions()
    {
        if (_distanceToPlayer <= visibilityDistance && 
            !_isVisible)
            SetVisibility(true);

        if (_currentFireRate <= 0 &&
            !_fov.CheckMiddleObstacle(_player.transform.position) && 
            _isVisible && 
            !_isCharging)
        {
            _isCharging = true;

            ParticleSystem chargeParticlesInstance = Instantiate(chargeParticlesPrefab, transform);
            chargeParticlesInstance.transform.position += transform.forward * .85f;
            chargeParticlesInstance.transform.localPosition -= Vector3.up * .5f;
            ParticleSystem.MainModule psMain = chargeParticlesInstance.main;
            psMain.duration = timeToFire;
            chargeParticlesInstance.Play();

            _chargeParticlesInstance = chargeParticlesInstance.gameObject;
            
            Invoke(nameof(Attack), timeToFire);   
        }
        else
            _currentFireRate -= Time.deltaTime;
    }

    private void Attack()
    {
        _isCharging = false;

        var pos = transform.position + transform.forward * 0.5f;
        
        Instantiate(shootParticlesPrefab, transform.position + transform.forward * .85f, Quaternion.LookRotation(transform.forward, transform.up));
        Instantiate(laserPrefab, pos, Quaternion.LookRotation(transform.forward, transform.up));
        
        AudioManager.Instance.PlayAudioClip(Sounds.SoundType.EnemyLaser, pos);

        SetVisibility(false);
        Teleport();

        _currentFireRate = _fireRate;
    }

    private void Teleport()
    {
        bool canTeleport = false;

        do
        {
            Vector3 randomPos = Random.insideUnitSphere * teleportDistance + transform.position;
            randomPos.y = transform.position.y;

            var colliders = Physics.OverlapSphere(randomPos, 1f, tpMaskObstacle);

            if (colliders.Length == 0 && !_fov.CheckMiddleObstacle(randomPos))
            {
                transform.position = randomPos;
                canTeleport = true;
            }

        } while (!canTeleport);
    }

    private void SetVisibility(bool isVisible)
    {
        Instantiate(isVisible ? appearParticlesPrefab : disappearParticlesPrefab, transform.position,
            Quaternion.LookRotation(transform.forward, transform.up));

        _isVisible = isVisible;
        _model.SetActive(isVisible);
        _collider.enabled = isVisible;
    }

    protected override void Move()
    {
        if (!_isVisible)
            return;
        
        RotateTowards(_player.transform.position);
    }

    public bool GetVisibility()
    {
        return _isVisible;
    }
    
    protected override IEnumerator StunEnemy()
    {
        absorbImg.SetActive(true);
        
        _isCharging = false;

        yield return StartCoroutine(base.StunEnemy());
        absorbImg.SetActive(false);
    }
    
    private void ResetAttackIndicator()
    {
        if (!_lineRenderer.enabled)
            return;
        
        _lineRenderer.positionCount = 0;
        _lineRenderer.enabled = false;
    }
    
    private void DrawAttackIndicator()
    {
        if (!_lineRenderer.enabled)
            _lineRenderer.enabled = true;
        
        _lineRenderer.positionCount = 2;

        const float maxDistance = 31; //hardcoded laser beam range

        var t = transform;
        var position = t.position;
        var forward = t.forward;
        
        var startPos = position + forward * .85f;
        var endPos = position + forward * maxDistance;

        // Add player to mask
        var layerMask = _fov.obstacleMask | (1 << 9);
        
        var attackEndPos = endPos;
        if (Physics.Raycast(startPos, transform.forward, out var hit, maxDistance, layerMask))
            attackEndPos = hit.point;

        _lineRenderer.SetPosition(0, startPos);
        _lineRenderer.SetPosition(1, attackEndPos);
    }

    private void OnDrawGizmosSelected()
    {
        Gizmos.color = Color.blue;
        Gizmos.DrawWireSphere(transform.position, teleportDistance);

        Gizmos.color = Color.green;
        Gizmos.DrawWireSphere(transform.position, visibilityDistance);
    }
}
