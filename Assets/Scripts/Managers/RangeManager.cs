using System.Collections.Generic;
using System.Linq;
using UnityEngine;

public class RangeManager : MonoBehaviour
{
    public static RangeManager Instance = null;
    
    private List<RangeIndicator> _enemyIndicators = new List<RangeIndicator>();
    private List<RangeIndicator> _submoduleIndicators = new List<RangeIndicator>();
    private PlayerModel _player;

    private void Awake()
    {
        if (Instance == null)
            Instance = this;
    }

    private void Start()
    {
        EventManager.Instance.Subscribe(EventManager.NameEvent.OnPlayerSpawned, OnPlayerSpawned);
        EventManager.Instance.Subscribe(EventManager.NameEvent.OnReturnedBoss, OnReturnedBoss);
    }

    private void Update()
    {
        CheckRangeDistance();
    }

    private RangeIndicator _closestIndicator;
    private void CheckRangeDistance()
    {
        if (CheckPlayer())
            return;
        
        RangeIndicator closest = null;
        var closestDistance = float.MaxValue;

        // First check for submodule indicators...
        GetClosestIndicator(ref closest, ref closestDistance, true);
        
        // Then check for enemy indicators if there are no submodule indicators...
        if (closest == null)
            GetClosestIndicator(ref closest, ref closestDistance, false);
        
        
        // Verify if the closest changed or not
        // If it doesn't changed, is not required to reset all the indicators
        if (closest == _closestIndicator)
            return;
        
        _closestIndicator = closest;

        // Reset all submodules indicators except the closest one
        _submoduleIndicators?.Where(entity => entity != null && entity.isActiveAndEnabled).ToList()
            .ForEach(entity => entity.SetColor(entity == closest && closestDistance <= _player.absorbDistance));
        
        // Reset all enemy indicators except the closest one
        _enemyIndicators?.Where(entity => entity != null && entity.isActiveAndEnabled).ToList()
            .ForEach(entity => entity.SetColor(entity == closest && closestDistance <= _player.absorbDistance));
    }

    private void GetClosestIndicator(ref RangeIndicator closest, ref float closestDistance, bool isSubModule)
    {
        var indicators = isSubModule ? _submoduleIndicators : _enemyIndicators;

        foreach (var indicator in indicators)
        {
            if (indicator == null || !indicator.isActiveAndEnabled)
                continue;
            
            var distance = Vector3.Distance(_player.transform.position, indicator.transform.position);
            
            if (!(distance < closestDistance) || !(distance <= _player.absorbDistance)) 
                continue;
            
            closest = indicator;
            closestDistance = distance;
        }
    }
    
    private void OnPlayerSpawned(params object[] parameters)
    {
        _player = (PlayerModel) parameters[1];
    }
    
    private void OnReturnedBoss(params object[] parameters)
    {
        _player = LevelManager.Instance.GetPlayer();
    }
    
    public void AddIndicator(RangeIndicator indicator, bool isSubModule)
    {
        if (isSubModule)
            _submoduleIndicators.Add(indicator);
        else
            _enemyIndicators.Add(indicator);
    }
    
    /// <summary>
    /// Check if the player exists in the level
    /// </summary>
    /// <returns></returns>
    private bool CheckPlayer()
    {
        if (_player == null)
            _player = LevelManager.Instance.GetPlayer();

        return _player == null;
    }
}
