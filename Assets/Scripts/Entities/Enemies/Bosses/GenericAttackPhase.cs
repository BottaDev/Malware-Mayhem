using System;
using System.Collections;
using System.Linq;
using UnityEngine;
using UnityEngine.AI;
using Random = UnityEngine.Random;

public class GenericAttackPhase : MonoBehaviour
{
    [SerializeField] private BossPhase[] bossPhases;

    private float _accumulatedRotation;
    private float _currentFireRate;
    private float _currentPatternDuration;
    private const float _maxAngle = 360f;
    private Entity _boss;
    private int _currentPattern;
    private int _lastPattern = -1;
    private int _currentPhase;
    private int _currentWayPoint;
    private NavMeshAgent _agent;
    private bool _isChangingPattern;     // If it's true, the boss will not shoot
    private PlayerModel _player;

    private bool _canAttack;    // Used in the initial wait time of the level, when the player spawns
    
    [System.Serializable]
    public class BossPhase
    {
        public string name;
        public BossPattern[] patterns;
        public Transform[] wayPoints;
    }

    [System.Serializable]
    public class BossPattern
    {
        public string name;
        [Range(0.1f, 120f)] public float duration;
        [Tooltip("The time that must pass to execute the following pattern")]
        public float waitTime = 1f;
        public BossBulletType projectile = BossBulletType.MediumGreen;
        [Range(0, 100)] public int numberOfProjectiles;
        [Range(0.1f, 1f)] public float fireRate = 0.1f;
        [Range(0f, 10f)] public float radius;
        [Range(0f, 360f)] public float rotationPerSecond = 90;
        public bool changeDirection;
    }

    private void Awake()
    {
        _agent = GetComponent<NavMeshAgent>();
        _boss = GetComponent<Entity>();
        
        _currentPatternDuration = bossPhases[_currentPhase].patterns[_currentPattern].duration;
        _lastPattern = _currentPattern;
        
        if (_agent != null && _agent.stoppingDistance == 0)
            _agent.stoppingDistance = 1f;
    }

    private void Start()
    {
        EventManager.Instance.Subscribe(EventManager.NameEvent.OnReturnedBoss, OnReturnedBoss);
        EventManager.Instance.Subscribe(EventManager.NameEvent.OnAbsorbedSubmodule, OnAbsorbedSubmodule);
        EventManager.Instance.Subscribe(EventManager.NameEvent.OnInitialAttackWait, OnInitialAttackWait);
    }

    public void Update()
    {
        if (_boss.hp <= 0 ||
            CheckPlayer() ||
            BossManager.Instance.GetAttackPause() ||
            !_canAttack)
        {
            return;   
        }

        if (!_isChangingPattern)
        {
            if (_currentPatternDuration <= 0)
                ChangePattern();
            else
                _currentPatternDuration -= Time.deltaTime;

            if (_currentFireRate <= 0)
                SpawnBullets();
            else
                _currentFireRate -= Time.deltaTime;
        }

        Move();
        
        AccumulateRotation();
    }

    /// <summary>
    /// Add the rotation to the spawn of the bullets
    /// </summary>
    private void AccumulateRotation()
    {
        _accumulatedRotation += Time.deltaTime * bossPhases[_currentPhase].patterns[_currentPattern].rotationPerSecond;
        if (_accumulatedRotation >= _maxAngle)
            _accumulatedRotation  = 0;
    }
    
    private void Move()
    {
        if (bossPhases[_currentPhase].wayPoints.Length <= 0)
            return;

        _agent.speed = _boss.movementSpeed;

        var distance = Vector3.Distance(bossPhases[_currentPhase].wayPoints[_currentWayPoint].position, transform.position);
        if (distance <= _agent.stoppingDistance)
        {
            _currentWayPoint++;
            if (_currentWayPoint > bossPhases[_currentPhase].wayPoints.Length - 1)
                _currentWayPoint = 0;
        }

        _agent.destination = bossPhases[_currentPhase].wayPoints[_currentWayPoint].position;
    }

    private void SpawnBullets()
    {
        var angle = _maxAngle / bossPhases[_currentPhase].patterns[_currentPattern].numberOfProjectiles;

        for (var i = 0; i < bossPhases[_currentPhase].patterns[_currentPattern].numberOfProjectiles; i++)
        {
            var rotation = !bossPhases[_currentPhase].patterns[_currentPattern].changeDirection ? 
                Quaternion.AngleAxis(i * angle + _accumulatedRotation, Vector3.up) : 
                Quaternion.AngleAxis(i * angle - _accumulatedRotation, Vector3.up);

            var direction = rotation * Vector3.forward;
            var position = transform.position + (direction * bossPhases[_currentPhase].patterns[_currentPattern].radius);

            // Fix the Y of the spawn
            const float yAxis = 1f;
            
            position = new Vector3(position.x, yAxis, position.z);

            Bullet bullet;
            
            switch (bossPhases[_currentPhase].patterns[_currentPattern].projectile)
            {
                case BossBulletType.RapidGreen:
                    bullet = EnemyPoolManager.Instance.rapidGreenBossBulletPool.Get();
                    bullet.pool = EnemyPoolManager.Instance.rapidGreenBossBulletPool;
                    break;
                case BossBulletType.MediumGreen:
                    bullet = EnemyPoolManager.Instance.mediumGreenBossBulletPool.Get();
                    bullet.pool = EnemyPoolManager.Instance.mediumGreenBossBulletPool;
                    break;
                case BossBulletType.SlowGreen:
                    bullet = EnemyPoolManager.Instance.slowGreenBossBulletPool.Get();
                    bullet.pool = EnemyPoolManager.Instance.slowGreenBossBulletPool;
                    break;
                
                case BossBulletType.RapidRed:
                    bullet = EnemyPoolManager.Instance.rapidRedBossBulletPool.Get();
                    bullet.pool = EnemyPoolManager.Instance.rapidRedBossBulletPool;
                    break;
                case BossBulletType.MediumRed:
                    bullet = EnemyPoolManager.Instance.mediumRedBossBulletPool.Get();
                    bullet.pool = EnemyPoolManager.Instance.mediumRedBossBulletPool;
                    break;
                case BossBulletType.SlowRed:
                    bullet = EnemyPoolManager.Instance.slowRedBossBulletPool.Get();
                    bullet.pool = EnemyPoolManager.Instance.slowRedBossBulletPool;
                    break;
                
                case BossBulletType.RapidBlue:
                    bullet = EnemyPoolManager.Instance.rapidBlueBossBulletPool.Get();
                    bullet.pool = EnemyPoolManager.Instance.rapidBlueBossBulletPool;
                    break;
                case BossBulletType.MediumBlue:
                    bullet = EnemyPoolManager.Instance.mediumBlueBossBulletPool.Get();
                    bullet.pool = EnemyPoolManager.Instance.mediumBlueBossBulletPool;
                    break;
                case BossBulletType.SlowBlue:
                    bullet = EnemyPoolManager.Instance.slowBlueBossBulletPool.Get();
                    bullet.pool = EnemyPoolManager.Instance.slowBlueBossBulletPool;
                    break;
                
                case BossBulletType.RapidOrange:
                    bullet = EnemyPoolManager.Instance.rapidOrangeBossBulletPool.Get();
                    bullet.pool = EnemyPoolManager.Instance.rapidOrangeBossBulletPool;
                    break;
                case BossBulletType.MediumOrange:
                    bullet = EnemyPoolManager.Instance.mediumOrangeBossBulletPool.Get();
                    bullet.pool = EnemyPoolManager.Instance.mediumOrangeBossBulletPool;
                    break;
                case BossBulletType.SlowOrange:
                    bullet = EnemyPoolManager.Instance.slowOrangeBossBulletPool.Get();
                    bullet.pool = EnemyPoolManager.Instance.slowOrangeBossBulletPool;
                    break;
                default:
                    throw new ArgumentOutOfRangeException();
            }
            
            bullet.transform.position = position;
            bullet.transform.rotation = rotation;
        }
        
        _currentFireRate = bossPhases[_currentPhase].patterns[_currentPattern].fireRate;
    }

    /// <summary>
    /// Change the current phase when a module is destroyed
    /// </summary>
    public void ChangePhase()
    {
        _currentPhase++;
        
        _currentPattern = Enumerable.Range(0, bossPhases[_currentPhase].patterns.Length).OrderBy(_ => Random.value).First();
        _lastPattern = _currentPattern;
        _currentPatternDuration = bossPhases[_currentPhase].patterns[_currentPattern].duration;
        
        _currentWayPoint = 0;
    }

    private void ChangePattern()
    {
        _lastPattern = _currentPattern;
        
        switch (bossPhases[_currentPhase].patterns.Length)
        {
            case 1:
                _currentPattern = 0;
                break;
            
            case 2:
                if (_currentPattern == bossPhases[_currentPhase].patterns.Length - 1)
                    _currentPattern = 0;
                else
                    _currentPattern++;
                break;
            
            default:
                // Get a new pattern from phase, that is no the same as the current one or the last pattern...
                _currentPattern = Enumerable.Range(0, bossPhases[_currentPhase].patterns.Length)
                    .Where(x => x != _currentPattern && x != _lastPattern)
                    .OrderBy(_ => Random.value)
                    .First();
                break;
        }

        _currentPatternDuration = bossPhases[_currentPhase].patterns[_currentPattern].duration;

        _currentFireRate = bossPhases[_currentPhase].patterns[_currentPattern].fireRate;

        if (bossPhases[_currentPhase].patterns[_currentPattern].waitTime > 0)
            StartCoroutine(Stop());
    }

    /// <summary>
    /// Check if the player exists in the level
    /// </summary>
    /// <returns></returns>
    private bool CheckPlayer()
    {
        if (_player == null)
            _player = LevelManager.Instance.GetPlayer();

        return _player == null;
    }
    
    private IEnumerator Stop()
    {
        _isChangingPattern = true;
        yield return new WaitForSeconds(bossPhases[_currentPhase].patterns[_currentPattern].waitTime);
        _isChangingPattern = false;
    }
    
    private void OnReturnedBoss(params object[] parameters)
    {
        // Reset the attack pattern...
        _isChangingPattern = false;
        _canAttack = true;
    }

    private void OnAbsorbedSubmodule(params object[] parameters)
    {
        _canAttack = false;
    }
    
    private void OnInitialAttackWait(params object[] parameters)
    {
        _canAttack = true;
    }

    public void SetCanAttack(bool canAttack)
    {
        _canAttack = canAttack;
    }

    public enum  BossBulletType
    {
        RapidGreen,
        MediumGreen,
        SlowGreen,
        RapidRed,
        MediumRed,
        SlowRed,
        RapidBlue,
        MediumBlue,
        SlowBlue,
        RapidOrange,
        MediumOrange,
        SlowOrange,
    }
}