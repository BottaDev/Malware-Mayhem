using UnityEngine;

public abstract class Arm : MonoBehaviour, IArm
{
    [Header("General Parameters")] public float speed = 20f;
    public float minAngle = -30;
    public float maxAngle = 180;
    public bool isLeft;
    [Tooltip("The percentage that the arm will lose")]
    [Range(min: 0, max: 100)] public float useDurationLoss = 10f;

    [Header("Attached Auto-Aim Parameters")]
    public float autoAimArea = 1;
    public float autoAimRange = 10;
    public LayerMask enemyLayerMask;

    private const float _totalEnergy = 100f;
    private float _currentEnergy;
    protected PlayerController _controller;
    
    private PlayerModel _model;

    protected virtual void Awake()
    {
        var root = transform.root;
        
        _model = root.GetComponent<PlayerModel>();
        _controller = root.GetComponent<PlayerController>();

        _currentEnergy = _totalEnergy;
    }

    protected virtual void Update()
    {
        Rotate();
    }

    protected void SubtractEnergy()
    {
        _currentEnergy -= useDurationLoss;
        
        UIManager.Instance.SetArmEnergy(isLeft, _currentEnergy);
    }

    private void Rotate()
    {
        var point = InputManager.Instance.mousePosition;
        
        var angle = Vector3.SignedAngle(point - transform.position, _model.torso.transform.forward, Vector3.up); 
        angle *= isLeft ? 1 : -1;

        if (!(angle >= minAngle) || !(angle <= maxAngle)) 
            return;
        
        var pivotTransform = _model.torso.transform.position;

        var p = transform.position;
        var nextForward = new Vector3(point.x, p.y, point.z) - 
                          new Vector3(p.x, p.y, p.z);
        
        var aimTarget = GetAutoAimTarget(nextForward);
        if (aimTarget != Vector3.zero)
        {
            pivotTransform = transform.position;
            point = aimTarget;
        }

        var transform1 = transform;
        var position1 = transform1.position;
        transform1.forward = new Vector3(point.x, position1.y, point.z) - 
                             new Vector3(pivotTransform.x, position1.y, pivotTransform.z);
    }

    private Vector3 GetAutoAimTarget(Vector3 nextForward)
    {
        var possibleTargets = Physics.BoxCastAll(transform.position, Vector3.one * autoAimArea / 2, nextForward, Quaternion.identity, autoAimRange, enemyLayerMask);

        if (possibleTargets.Length <= 0) 
            return Vector3.zero;
        
        float closestDist = 100;
        var closest = Vector3.zero;
        foreach (var item in possibleTargets)
        {
            var position = transform.position;
            var dist = GetDistanceToLine(item.collider.transform.position, position, position + nextForward * autoAimRange);
            if (!(dist < closestDist)) 
                continue;
            
            closestDist = dist;
            closest = item.collider.transform.position;
        }
            
        return closest;

    }

    private static float GetDistanceToLine(Vector3 aSourcePoint, Vector3 aStart, Vector3 aEnd)
    {
        var ba = aEnd - aStart;
        var va = aSourcePoint - aStart;
        var w2 = va - ((ba * Vector3.Dot(va, ba)) / ba.sqrMagnitude);
        var pointOnLine = aSourcePoint - w2;

        return (aSourcePoint - pointOnLine).magnitude;
    }

    /// <summary>
    /// Sets the energy of the arm to the total energy
    /// </summary>
    public void ResetEnergy()
    {
        _currentEnergy = _totalEnergy;
    }
    
    public float GetDuration()
    {
        return _currentEnergy;
    }

    private void OnDrawGizmos()
    {
        var transform1 = transform;
        var position = transform1.position;
        var forward = transform1.forward;
        
        Gizmos.color = Color.green;
        
        Gizmos.DrawRay(position + transform1.right * autoAimArea/2,  forward * autoAimRange);
        Gizmos.DrawRay(position + transform.right * -autoAimArea/2, forward * autoAimRange);
    }

    public virtual void MakeAction() { }
}
