using MM.Common;
using UnityEngine;
using Random = UnityEngine.Random;

namespace MM.Entities.Enemies.Bosses.Iset
{
    public class IsetHookAttack : SubmoduleAttack
    {
        #region Private Variables
        [Tooltip("The maximum time that the boss can move to the hook. This is to prevent the boss to be stuck searching the hook")]
        [SerializeField] private float maxTimeToGetClose = 7f;
        [Header("Hook Parameters")]
        [SerializeField] private float hookDamage = 10f;
        [SerializeField] private float timeBeforeHook = 1.5f;
        [Tooltip("The distance that the boss must reach to shoot all the bullets")]
        [SerializeField] private float hookDistance = 1.082f;
        [SerializeField] private Transform hookInitialPosition;
        [SerializeField] private GameObject hook;
        [Space]
        [Header("Bullet Parameters")]
        [SerializeField] private BossBulletType typeOfBulletToDivide = BossBulletType.RapidBlue;
        [SerializeField] private int numberOfBulletsToDivide = 20;
        
        private IsetMobilizer _mobilizer;
        private BossArm _arm;
        private IsetHook _currentHook;
        private bool _hookShot;
        private bool _shouldStopAttack;
        #endregion
        
        #region MonoBehaviour Functions
        protected override void Start()
        {
            base.Start();
            _mobilizer = GetComponentInParent<IsetMobilizer>();
            _arm = GetComponent<BossArm>();
            
            InstantiateHook();
        }
        private void Update()
        {
            CheckHook();
        }
        #endregion
        
        #region Private Functions
        private void CheckHook()
        {
            var position = _mobilizer.gameObject.transform.position;

            if (_currentHook == null)
                InstantiateHook();
            
            if (_hookShot && 
                Vector3.Distance(position, _currentHook.transform.position) <= hookDistance && 
                _shouldStopAttack)
                StopAttack();   
        }
        
        /// <summary>
        /// Make the final part of the attack
        /// </summary>
        private void StopAttack()
        {
            if (!_shouldStopAttack) 
                return;
            
            _hookShot = false;
            _arm.SetLookAtObject(false);
                
            Destroy(_currentHook.gameObject);
            InstantiateHook();
                
            SpawnBullets();
            
            _shouldStopAttack = false;
        }
        
        private void InstantiateHook()
        {
            var hookInstance = Instantiate(hook, hookInitialPosition.position, hookInitialPosition.rotation, gameObject.transform);
            _currentHook = hookInstance.GetComponent<IsetHook>();
            _currentHook.SetDamage(hookDamage);
        }
        
        /// <summary>
        /// Spawns the bullets in a circle around the boss
        /// </summary>
        private void SpawnBullets()
        {
            const float angleRange = 360f;
            var angleStep = angleRange / numberOfBulletsToDivide;

            for (var i = 0; i < numberOfBulletsToDivide; i++)
            {
                var currentAngle = i * angleStep + Random.Range(0f, 360f);
                var rotation = Quaternion.AngleAxis(currentAngle, Vector3.up);

                var direction = rotation * Vector3.forward;
                var position = transform.position + direction;

                // Fix the Y of the spawn
                const float yAxis = 1f;
            
                position = new Vector3(position.x, yAxis, position.z);

                var bullet = EnemyPoolManager.Instance.GetBossBullet(typeOfBulletToDivide);

                var bulletTransform = bullet.transform;
                bulletTransform.position = position;
                bulletTransform.rotation = rotation;
            }
            
            // Restore the normal movement
            _mobilizer.SetMovingToHook(false);
            _mobilizer.RestartMovement();
        }

        private void ShootHookWithMovement()
        {
            // Stop the invoke of the function if the boss reached the hook
            CancelInvoke(nameof(ShootHookWithMovement));
            _shouldStopAttack = true;
            
            _mobilizer.SetMovingToHook(true);
            
            _currentHook.Shoot();
                
            _arm.SetLookAtObject(_currentHook);
            _hookShot = true;
        }

        private void ShootHookWithOutMovement()
        {
            // Stop the invoke of the function if the boss reached the hook
            CancelInvoke(nameof(ShootHookWithMovement));
            _shouldStopAttack = true;
            
            _currentHook.Shoot(false);
                
            _arm.SetLookAtObject(_currentHook);
            _hookShot = true;
        }
        
        private void SelectAttack()
        {
            // Get a random between 1 and 3
            var random = Random.Range(1, 4);

            switch (random)
            {
                case 1:
                    ShootHookWithMovement();
                    break;
                case 2:
                case 3:
                    ShootHookWithOutMovement();
                    break;
            }
        }
        #endregion
        
        #region Public Functions
        public override void MakeAction()
        {
            base.MakeAction();
            
            _arm.SetLookAtObject(true);
            
            Invoke(nameof(SelectAttack), timeBeforeHook);
        }
        
        public void MoveToHook()
        {
            _mobilizer.MoveToHook(_currentHook.transform.position);
            
            // Start the counter to get close to the hook
            Invoke(nameof(StopAttack), maxTimeToGetClose);
        }
        
        public Transform GetShotSpawn()
        {
            return hookInitialPosition;
        }
        #endregion
    }
}
