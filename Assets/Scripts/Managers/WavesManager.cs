using System;
using System.Collections;
using System.Collections.Generic;
using UnityEngine;
using Random = UnityEngine.Random;

public class WavesManager : MonoBehaviourSingleton<WavesManager>
{
    [SerializeField] private Waves[] waves;
    [SerializeField] private float timeBetweenWaves;
    private bool _waveFinished = true;
    private bool _cantStart;
    private float _currentTime;
    private int _totalEnemies;
    private int _currentWave = -1;
    private TutorialPhases _currentPhase;
    private List<BossSubmodule> _miniPillars = new();
    private bool _pillarsActive;
    
    private PlayerController _player;

    private void Start()
    {
        EventManager.Instance.Subscribe(EventManager.NameEvent.OnEnemyDead, OnEnemyDead);
        EventManager.Instance.Subscribe(EventManager.NameEvent.OnBossSubmoduleDeath, OnBossSubmoduleDeath);
        EventManager.Instance.Subscribe(EventManager.NameEvent.OnTextStarted, OnTextStarted);
        EventManager.Instance.Subscribe(EventManager.NameEvent.OnTextFinished, OnTextFinished);
        EventManager.Instance.Subscribe(EventManager.NameEvent.OnStunnedEnemy, OnStunnedEnemy);
        EventManager.Instance.Subscribe(EventManager.NameEvent.OnAbsorbingEnemy, OnAbsorbingEnemy);
        EventManager.Instance.Subscribe(EventManager.NameEvent.OnPlayerSpawned, OnPlayerSpawned);
        
        _currentTime = timeBetweenWaves;
    }

    private void Update()
    {
        if(!_waveFinished || _currentWave >= waves.Length || _cantStart) return;

        if (_currentTime <= 0)
            SetWave();
        else
            _currentTime -= Time.deltaTime;
    }

    private void SetWave()
    {
        _waveFinished = false;
        _currentTime = timeBetweenWaves;
        _currentWave++;
        _currentPhase = waves[_currentWave].phase;
        
        if(waves[_currentWave].hasText)
            TextBoxManager.Instance.SetText(waves[_currentWave].texts);

        if (waves[_currentWave].hasEnemies)
            _totalEnemies = waves[_currentWave].totalEnemies;

        switch (_currentPhase)
        {
            case TutorialPhases.MovementsPhase:
                
                if(waves[_currentWave].hasText)
                    TextBoxManager.Instance.StartText();
                else
                    StartWave();
                
                break;
            
            case TutorialPhases.HealingPhase:
                StartWave();
                break;
            
            case TutorialPhases.ArmsPhase:
                if(_currentWave == 7)
                {
                    EventManager.Instance.Subscribe(EventManager.NameEvent.OnStunnedEnemy, OnStunnedEnemy);
                    StartWave();
                    _waveFinished = true;
                    _currentTime = 10;
                    _pillarsActive = true;
                }
                else
                {
                    StartWave();
                }
                break;
            
            case TutorialPhases.BossPhase:
                if (_currentWave == 10)
                {
                    StartWave();
                    _waveFinished = true;
                    _currentTime = 2;
                }
                else
                {
                    StartWave();
                }
                break;
        }
    }

    private void StartWave()
    {
        var currentPos = 0;
        var currentEnemy = 0;
        
        for (var i = 0; i < _totalEnemies; i++)
        {
            if(currentPos >= waves[_currentWave].spawnPoints.Count)
                currentPos = 0;
            
            var position = waves[_currentWave].spawnPoints[currentPos].position;
            currentPos++;
                
            
            if(currentEnemy >= waves[_currentWave].enemies.Count)
                currentEnemy = 0;
            
            var enemy = Instantiate(waves[_currentWave].enemies[currentEnemy], position, Quaternion.identity);
            if (_currentWave == 7)
            {
                _miniPillars.Add(enemy.GetComponent<BossSubmodule>());
            }
            
            currentEnemy++;
        }
    }

    private void RepeatWave()
    {
        _currentTime = timeBetweenWaves;
        _waveFinished = false;
        
        if(waves[_currentWave].hasText)
            TextBoxManager.Instance.SetText(waves[_currentWave].texts);

        if (waves[_currentWave].hasEnemies)
            _totalEnemies = _currentWave is 6 or 9 or 11 ? Random.Range(1,3) : waves[_currentWave].totalEnemies;

        StartCoroutine(StartRepeatedWave());
    }

    private IEnumerator StartRepeatedWave()
    {
        yield return new WaitForSeconds(_currentTime);
        
        StartWave();
    }

    private void OnStunnedEnemy(params object[] parameters)
    {
        TextBoxManager.Instance.StartText();
        EventManager.Instance.Unsubscribe(EventManager.NameEvent.OnStunnedEnemy, OnStunnedEnemy);
    }

    private void OnAbsorbingEnemy(params object[] parameters)
    {
        if(_currentPhase is TutorialPhases.HealingPhase)
        {
            _player.SetCantHeal(false);
            _player.SetCantChangeArm(true);
            UIManager.Instance.SetMergingUI(false, true);
            
            if(_currentWave == 5)
                TextBoxManager.Instance.ContinueText();
        }
        else if(_currentPhase is TutorialPhases.ArmsPhase)
        {
            _player.SetCantHeal(true);
            _player.SetCantChangeArm(false);
            UIManager.Instance.SetMergingUI(true, false);
            
            if(_currentWave == 8)
                TextBoxManager.Instance.ContinueText();
        }
        else
        {
            _player.SetCantHeal(false);
            _player.SetCantChangeArm(false);
            UIManager.Instance.SetMergingUI(true, true);
        }
    }
    
    private void OnEnemyDead(params object[] parameters)
    {
        _totalEnemies--;
        
        if (_totalEnemies <= 0)
        {
            if (_currentWave == 6 && !_player.GetComponent<PlayerModel>().IsFullHP())
            {
                RepeatWave();
                return;
            }
            if(_currentWave == 9 && _pillarsActive)
            {
                RepeatWave();
                return;
            }
            if (_currentWave == 11)
            {
                RepeatWave();
                return;
            }
            
            _waveFinished = true;
            EventManager.Instance.Trigger(EventManager.NameEvent.OnWaveFinished);
        }
    }

    private void OnTextFinished(params object[] parameters)
    {
        _cantStart = false;
        
        if(_currentPhase is TutorialPhases.MovementsPhase)
            StartWave();
    }

    private void OnTextStarted(params object[] parameters)
    {
        _cantStart = true;
    }

    private void OnPlayerSpawned(params object[] parameters)
    {
        _player = LevelManager.Instance.GetPlayer().GetComponent<PlayerController>();
    }

    private void OnBossSubmoduleDeath(params object[] parameters)
    {
        var bossSubmodule = (GameObject) parameters[0];
        
        _miniPillars.Remove(bossSubmodule.GetComponent<BossSubmodule>());
        if (_miniPillars.Count <= 0)
        {
            _pillarsActive = false;
        }
    }
}

[Serializable]
public struct Waves
{
    public TutorialPhases phase;
    public bool hasText;
    public AllTexts[] texts;
    public bool hasEnemies;
    public List<GameObject> enemies;
    public List<Transform> spawnPoints; 
    public int totalEnemies;
}

[Serializable]
public struct AllTexts
{ 
    public string texts;
    public bool stop;
}

public enum TutorialPhases
{
    MovementsPhase,
    HealingPhase,
    ArmsPhase,
    BossPhase
}