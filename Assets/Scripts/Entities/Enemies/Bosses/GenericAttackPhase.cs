using System.Collections;
using System.Linq;
using UnityEngine;
using UnityEngine.AI;
using Random = UnityEngine.Random;

public class GenericAttackPhase : MonoBehaviour
{
    [SerializeField] private BossPhase[] bossPhases;

    private float _accumulatedRotation;
    private float _currentFireRate;
    private float _currentPatternDuration;
    private const float _maxAngle = 360f;
    private Entity _boss;
    private int _currentPattern;
    private int _lastPattern = -1;
    private int _currentPhase;
    private int _currentWayPoint;
    private NavMeshAgent _agent;
    private bool _isChangingPattern;     // If it's true, the boss will not shoot
    private PlayerModel _player;

    private bool _canAttack;    // Used in the initial wait time of the level, when the player spawns
    
    [System.Serializable]
    public class BossPhase
    {
        public string name;
        public BossPattern[] patterns;
        public Transform[] wayPoints;
    }

    [System.Serializable]
    public class BossPattern
    {
        public string name;
        [Range(0.1f, 120f)] public float duration;
        [Tooltip("The time that must pass to execute the following pattern")]
        public float waitTime = 1f;
        public BossBulletType projectile = BossBulletType.Medium;
        [Range(0, 100)] public int numberOfProjectiles;
        [Range(0.1f, 1f)] public float fireRate = 0.1f;
        [Range(0f, 10f)] public float radius;
        [Range(0f, 360f)] public float rotationPerSecond = 90;
        public bool changeDirection;
    }

    private void Awake()
    {
        _agent = GetComponent<NavMeshAgent>();
        _boss = GetComponent<Entity>();
        
        _currentPatternDuration = bossPhases[_currentPhase].patterns[_currentPattern].duration;
        _lastPattern = _currentPattern;
        
        if (_agent != null && _agent.stoppingDistance == 0)
            _agent.stoppingDistance = 1f;
    }

    private void Start()
    {
        EventManager.Instance.Subscribe(EventManager.NameEvent.OnReturnedBoss, OnReturnedBoss);
        EventManager.Instance.Subscribe(EventManager.NameEvent.OnInitialAttackWait, OnInitialAttackWait);
    }

    public void Update()
    {
        if (_boss.hp <= 0 ||
            CheckPlayer() ||
            BossManager.Instance.GetAttackPause() ||
            !_canAttack)
        {
            return;   
        }

        if (!_isChangingPattern)
        {
            if (_currentPatternDuration <= 0)
                ChangePattern();
            else
                _currentPatternDuration -= Time.deltaTime;

            if (_currentFireRate <= 0)
                SpawnBullets();
            else
                _currentFireRate -= Time.deltaTime;
        }

        Move();
        
        AccumulateRotation();
    }

    /// <summary>
    /// Add the rotation to the spawn of the bullets
    /// </summary>
    private void AccumulateRotation()
    {
        _accumulatedRotation += Time.deltaTime * bossPhases[_currentPhase].patterns[_currentPattern].rotationPerSecond;
        if (_accumulatedRotation >= _maxAngle)
            _accumulatedRotation  = 0;
    }
    
    private void Move()
    {
        if (bossPhases[_currentPhase].wayPoints.Length <= 0)
            return;

        _agent.speed = _boss.movementSpeed;

        var distance = Vector3.Distance(bossPhases[_currentPhase].wayPoints[_currentWayPoint].position, transform.position);
        if (distance <= _agent.stoppingDistance)
        {
            _currentWayPoint++;
            if (_currentWayPoint > bossPhases[_currentPhase].wayPoints.Length - 1)
                _currentWayPoint = 0;
        }

        _agent.destination = bossPhases[_currentPhase].wayPoints[_currentWayPoint].position;
    }

    private void SpawnBullets()
    {
        var angle = _maxAngle / bossPhases[_currentPhase].patterns[_currentPattern].numberOfProjectiles;

        for (var i = 0; i < bossPhases[_currentPhase].patterns[_currentPattern].numberOfProjectiles; i++)
        {
            var rotation = !bossPhases[_currentPhase].patterns[_currentPattern].changeDirection ? 
                Quaternion.AngleAxis(i * angle + _accumulatedRotation, Vector3.up) : 
                Quaternion.AngleAxis(i * angle - _accumulatedRotation, Vector3.up);

            var direction = rotation * Vector3.forward;
            var position = transform.position + (direction * bossPhases[_currentPhase].patterns[_currentPattern].radius);

            // Fix the Y of the spawn
            const float yAxis = 1f;
            
            position = new Vector3(position.x, yAxis, position.z);

            switch (bossPhases[_currentPhase].patterns[_currentPattern].projectile)
            {
                case BossBulletType.Rapid:
                    var rapidBullet = EnemyPoolManager.Instance.rapidBossBulletPool.Get();
                    rapidBullet.pool = EnemyPoolManager.Instance.rapidBossBulletPool;
                    rapidBullet.transform.position = position;
                    rapidBullet.transform.rotation = rotation;
                    break;
                case BossBulletType.Medium:
                    var mediumBullet = EnemyPoolManager.Instance.mediumBossBulletPool.Get();
                    mediumBullet.pool = EnemyPoolManager.Instance.mediumBossBulletPool;
                    mediumBullet.transform.position = position;
                    mediumBullet.transform.rotation = rotation;
                    break;
                case BossBulletType.Slow:
                    var slowBullet = EnemyPoolManager.Instance.slowBossBulletPool.Get();
                    slowBullet.pool = EnemyPoolManager.Instance.slowBossBulletPool;
                    slowBullet.transform.position = position;
                    slowBullet.transform.rotation = rotation;
                    break;
            }
        }
        
        _currentFireRate = bossPhases[_currentPhase].patterns[_currentPattern].fireRate;
    }

    /// <summary>
    /// Change the current phase when a module is destroyed
    /// </summary>
    public void ChangePhase()
    {
        _currentPhase++;
        
        _currentPattern = Enumerable.Range(0, bossPhases[_currentPhase].patterns.Length).OrderBy(_ => Random.value).First();
        _lastPattern = _currentPattern;
        _currentPatternDuration = bossPhases[_currentPhase].patterns[_currentPattern].duration;
        
        _currentWayPoint = 0;
    }

    private void ChangePattern()
    {
        _lastPattern = _currentPattern;
        
        switch (bossPhases[_currentPhase].patterns.Length)
        {
            case 1:
                _currentPattern = 0;
                break;
            
            case 2:
                if (_currentPattern == bossPhases[_currentPhase].patterns.Length - 1)
                    _currentPattern = 0;
                else
                    _currentPattern++;
                break;
            
            default:
                // Get a new pattern from phase, that is no the same as the current one or the last pattern...
                _currentPattern = Enumerable.Range(0, bossPhases[_currentPhase].patterns.Length)
                    .Where(x => x != _currentPattern && x != _lastPattern)
                    .OrderBy(_ => Random.value)
                    .First();
                break;
        }

        _currentPatternDuration = bossPhases[_currentPhase].patterns[_currentPattern].duration;

        _currentFireRate = bossPhases[_currentPhase].patterns[_currentPattern].fireRate;

        if (bossPhases[_currentPhase].patterns[_currentPattern].waitTime > 0)
            StartCoroutine(Stop());
    }

    /// <summary>
    /// Check if the player exists in the level
    /// </summary>
    /// <returns></returns>
    private bool CheckPlayer()
    {
        if (_player == null)
            _player = LevelManager.Instance.GetPlayer();

        return _player == null;
    }
    
    private IEnumerator Stop()
    {
        _isChangingPattern = true;
        yield return new WaitForSeconds(bossPhases[_currentPhase].patterns[_currentPattern].waitTime);
        _isChangingPattern = false;
    }
    
    private void OnReturnedBoss(params object[] parameters)
    {
        // Reset the attack pattern...
        _isChangingPattern = false;
    }
    
    private void OnInitialAttackWait(params object[] parameters)
    {
        _canAttack = true;
    }

    public void SetCanAttack(bool canAttack)
    {
        _canAttack = canAttack;
    }

    public enum  BossBulletType
    {
        Rapid,
        Medium,
        Slow
    }
}