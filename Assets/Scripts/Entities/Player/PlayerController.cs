using System.Collections;
using System.Linq;
using UnityEngine;

[RequireComponent(typeof(Rigidbody))]
public class PlayerController : MonoBehaviour
{
    public Pool<Bullet> bulletPool;
    public Pool<Bullet> assaultBulletPool;
    public Pool<Bullet> shieldBulletPool;

    private float _horizontalMovement;
    private float _verticalMovement;
    private Arm _currentLeftArm;
    private Arm _currentRightArm;
    private PlayerModel _model;
    private PlayerView _view;
    private Rigidbody _rb;
    private bool _leftArmToChange = true;
    private bool _isAbsorbing;
    private Vector3 _leftSpawnPosition;     // Location where the left arms will spawn when detached
    private Vector3 _rightSpawnPosition;    // Location where the right arms will spawn when detached
    private bool _canTakeDamage = true;
    private float _currentSpeed;
    private float _pullDown = 0.1f;  // dimensionless > 0, < 1 
    private float _maxOverSpeed;
    //private float _currentDashRate;
    private bool _lowLife;
    private float _percentage;
    private float _currentLeftLaunchRate;
    private float _currentRightLaunchRate;
    private Enemy _closeEnemy;
    private Camera _cam;
    
    private static bool IsPaused => PauseManager.Instance.isPaused;
    
    private void Awake()
    {
        _model = GetComponent<PlayerModel>();
        _view = GetComponent<PlayerView>();
        _rb = GetComponent<Rigidbody>();
        _cam = Camera.main;

        _maxOverSpeed = _model.movementSpeed + 1;
    }

    private void Start()
    {
        _currentLeftArm = _model.leftArms[0].arms[0];
        _currentRightArm = _model.rightArms[0].arms[0];
        
        // Set HP 
        UIManager.Instance.SetMaxHealth(_model.hp);
        
        CreatePools();
    }

    private void CreatePools()
    {
        BasicBulletFactory basicBulletFactory = new BasicBulletFactory();
        bulletPool = new Pool<Bullet>(basicBulletFactory.Create, Bullet.TurnOn, Bullet.TurnOff, 6);
        
        PlayerAssaultBulletFactory assaultBulletFactory = new PlayerAssaultBulletFactory();
        assaultBulletPool = new Pool<Bullet>(assaultBulletFactory.Create, Bullet.TurnOn, Bullet.TurnOff, 6);
        
        PlayerShieldBulletFactory shieldBulletFactory = new PlayerShieldBulletFactory();
        shieldBulletPool = new Pool<Bullet>(shieldBulletFactory.Create, Bullet.TurnOn, Bullet.TurnOff, 4);
    }
    
    private void Update()
    {
        /*if (Input.GetKeyDown(KeyCode.LeftShift) && _currentDashRate <= 0)
        {
            Vector3 movementDirection = new Vector3(_horizontalMovement, 0, _verticalMovement);
            StartCoroutine(Dash(movementDirection.normalized, _model.dashDuration, _model.dashDistance));
        }
        else
        {
            _currentDashRate -= Time.deltaTime;
        }*/
        if(IsPaused) return;

        if (_isAbsorbing)
        {
            PauseManager.Instance.isPlayerAbsorbing = true;
            if (Vector3.Distance(transform.position, _closeEnemy.transform.position) > _model.finisherDistance || !_closeEnemy.isStunned)
                _isAbsorbing = false;

            if (Input.GetKeyDown(KeyCode.Q) || Input.GetMouseButtonDown(0))
            {
                AudioManager.Instance.Play("AbsorbEnemy");
                _view.ShowAbsorptionEffect(_closeEnemy, _model.leftArmParticleForceField);
                _closeEnemy.KillEntity();
                SetArmToChange(_closeEnemy.type, true);
                _isAbsorbing = false;
            }
            else if (Input.GetKeyDown(KeyCode.E) || Input.GetMouseButtonDown(1))
            {
                AudioManager.Instance.Play("AbsorbEnemy");
                _view.ShowAbsorptionEffect(_closeEnemy, _model.rightArmParticleForceField);
                _closeEnemy.KillEntity();
                SetArmToChange(_closeEnemy.type, false);
                _isAbsorbing = false;
            }
            else if (Input.GetKeyDown(KeyCode.Space))
            {
                HealPlayer(_model.healAmount);
                _closeEnemy.KillEntity();
                _isAbsorbing = false;
            }
        }
        else
        {
            PauseManager.Instance.isPlayerAbsorbing = false;
            if (Input.GetMouseButton(0) || Input.GetMouseButtonDown(0))
            {
                if (_currentLeftArm.GetDuration() <= 0 && _canLaunchLeft)
                    LaunchArm(true);
                else
                    UseArm(true);
            }

            if (Input.GetMouseButton(1) || Input.GetMouseButtonDown(1))
            {
                if (_currentRightArm.GetDuration() <= 0 && _canLaunchRight)
                    LaunchArm(false);
                else
                    UseArm(false);
            }
            
            if (Input.GetKeyDown(KeyCode.Space))
                CheckStunnedEnemy();
        }
        
        if (_isAbsorbing)
        {
            Time.timeScale = Mathf.Lerp(Time.timeScale, _model.timeScaleSlow, _model.timeScaleSpeed * Time.deltaTime);
            _cam.fieldOfView = Mathf.Lerp(_cam.fieldOfView, _model.minCamFOV, _model.camZoomSpeed * Time.deltaTime);
        }
        else
        {
            Time.timeScale = Mathf.Lerp(Time.timeScale, 1, (_model.timeScaleSpeed * 2) * Time.deltaTime);
            _cam.fieldOfView = Mathf.Lerp(_cam.fieldOfView, _model.maxCamFOV, (_model.camZoomSpeed * 2) * Time.deltaTime);
        }
        
        //CheckArmsLaunch();
    }

    private void CheckArmsLaunch()
    {
        _currentLeftLaunchRate -= Time.deltaTime;
        _currentRightLaunchRate -= Time.deltaTime;
        
        if (_currentLeftArm != _model.leftArms[0].arms[0])
            CheckLaunchKey(true);

        if (_currentRightArm != _model.rightArms[0].arms[0])
            CheckLaunchKey(false);
    }

    private void CheckLaunchKey(bool isLeft)
    {
        // Prevent from throwing the arm if player don't have one at the moment...
        switch (isLeft)
        {
            case true when !_canLaunchLeft:
            case false when !_canLaunchRight:
                return;
        }

        var key = isLeft ? KeyCode.Q : KeyCode.E;
        var rate = isLeft ? _currentLeftLaunchRate : _currentRightLaunchRate;

        if (Input.GetKey(key) && rate <= 0)
        {
            LaunchArm(isLeft);
            ResetArmLaunchRate(isLeft);
        }
    }

    private void ResetArmLaunchRate(bool isLeft)
    {
        if (isLeft)
            _currentLeftLaunchRate = _model.launchRate;
        else
            _currentRightLaunchRate = _model.launchRate;
    }
    
    private void LaunchArm(bool isLeft)
    {
        var pos = _model.torso.transform.TransformPoint(isLeft ? 
            _currentLeftArm.gameObject.transform.localPosition : 
            _currentRightArm.gameObject.transform.localPosition);

        var armObj = isLeft ? _currentLeftArm.gameObject : _currentRightArm.gameObject;
        var armRot = isLeft ? _currentLeftArm.gameObject.transform.rotation : _currentRightArm.gameObject.transform.rotation;
        var localScale = _model.torso.transform.localScale;
            
        Arm newArm = Instantiate(armObj, pos, armRot).GetComponent<Arm>();
            
        // Adjust the scale
        newArm.gameObject.transform.localScale = new Vector3(localScale.x, localScale.y, localScale.z);
            
        newArm.SetDurationTime(isLeft ? _currentLeftArm.GetDuration() : _currentRightArm.GetDuration());
        newArm.LaunchArm(_model.launchDistance, _model, this);
     
        Invoke(isLeft ? nameof(ResetLeftLaunchedArm) : nameof(ResetRightLaunchedArm) , _model.armResetTime);
        
        _view.ResetArm(isLeft ? _currentLeftArm : _currentRightArm);

        if (isLeft)
            _canLaunchLeft = false;
        else
            _canLaunchRight = false;
    }

    private void UseArm(bool left)
    {
        if (IsPaused) return;
        
        if (left)
            _currentLeftArm.MakeAction();
        else
            _currentRightArm.MakeAction();
    }
    
    private void CheckStunnedEnemy()
    {
        // Enemy
        int layerMask = 1 << 8;

        var enemies = Physics.OverlapSphere(transform.position, _model.finisherDistance, layerMask)
            .Select(x => x.GetComponent<Enemy>()).ToList();
        
        _closeEnemy = enemies.Where(x=> x.GetIsStunned())
            .OrderBy(x => Vector2.Distance(transform.position, x.transform.position))
            .ToList()
            .FirstOrDefault();

        if (_closeEnemy != null && !_isAbsorbing)
            StartCoroutine(AbsorbEnemy());
    }

    private IEnumerator AbsorbEnemy()
    {
        _isAbsorbing = true;
        UIManager.Instance.ToggleAbsorbMenu(true);
        
        yield return new WaitWhile(() => _isAbsorbing);

        _closeEnemy = null;
        UIManager.Instance.ToggleAbsorbMenu(false);
    }

    private void ResetLeftLaunchedArm()
    {
        SetArm(true, 0,0);
    }

    private void ResetRightLaunchedArm()
    {
        SetArm(false, 0,0);
    }

    private bool _canLaunchLeft = true;
    private bool _canLaunchRight = true;
    private void SetArm(bool isLeft, int armSet, int armIndex)
    {
        UIManager.Instance.SetArmBar(isLeft, armSet);
        
        if (isLeft)
        {
            _currentLeftArm = _model.leftArms[armSet].arms[armIndex];
            _currentLeftArm.ResetDuration();
            _view.ShowArm(_model.leftArms, armSet, armIndex);
            _canLaunchLeft = true;
            _currentLeftArmUpgrade = armIndex;
        }
        else
        {
            _currentRightArm = _model.rightArms[armSet].arms[armIndex];
            _currentRightArm.ResetDuration();
            _view.ShowArm(_model.rightArms, armSet, armIndex);
            _canLaunchRight = true;
            _currentRightArmUpgrade = armIndex;
        }
    }
    
    private void SetArmToChange(Enemy.EnemyType type, bool isLeftArm)
    {
        var armSetIndex = GetArmSetIndex(type);
        var armUpgradeIndex = GetArmUpgradeIndex(armSetIndex);

        SetArm(isLeftArm, armSetIndex, armUpgradeIndex);
    }

    // From 0 to 2
    private int _currentLeftArmUpgrade = 0;
    private int _currentRightArmUpgrade = 0;

    private int GetArmUpgradeIndex(int newArmSetIndex)
    {
        const int maxUpgrade = 2;
        
        var currentArmUpgrade = _leftArmToChange ? _currentLeftArmUpgrade : _currentRightArmUpgrade;
        var armSet = _leftArmToChange ? _model.leftArms : _model.rightArms;

        var currentArmSetIndex = armSet.FindIndex(x => x.arms.Contains(_leftArmToChange ? _currentLeftArm : _currentRightArm));

        if (newArmSetIndex == currentArmSetIndex)
        {
            return currentArmUpgrade < maxUpgrade ? currentArmUpgrade + 1 : maxUpgrade;
        }

        return 0;
    }
    
    private int GetArmSetIndex(Enemy.EnemyType type)
    {
        switch (type)
        {
            default:
                return 0;
            
            case Enemy.EnemyType.LaserPorter:
                return 1;
            
            case Enemy.EnemyType.AssaultBox:
                return 2;
            
            case Enemy.EnemyType.Shielder:
                return 3;
            
            case Enemy.EnemyType.Blader:
                return 4;
        }
    }
    
    private void FixedUpdate()
    {
        Move();
        RotateTorso();
    }
    
    private void Move()
    {
        _horizontalMovement = Input.GetAxisRaw("Horizontal");
        _verticalMovement = Input.GetAxisRaw("Vertical");

        Vector3 movementDirection = new Vector3(_horizontalMovement, 0, _verticalMovement);

        Accelerate(movementDirection.normalized);
        
        if (movementDirection == Vector3.zero)
            _currentSpeed = 0;

        _view.ShowDustVfx(_horizontalMovement, _verticalMovement);
        
        RotateLegs(movementDirection);
    }
    
    private void Accelerate(Vector3 dir)
    {
        if (_currentSpeed < _model.movementSpeed)
            _currentSpeed += _model.acceleration;

        // Clamp max over speed
        _currentSpeed = _currentSpeed > _maxOverSpeed ? _maxOverSpeed : _currentSpeed;

        float speedAdjust = _currentSpeed - _model.movementSpeed;

        // Pull speed down if needed
        _currentSpeed -= speedAdjust > 0.0f ? speedAdjust * _pullDown : 0.0f;

        // Set the velocity magnitude to the new speed
        _rb.velocity = dir * _currentSpeed;
    }

    private void RotateLegs(Vector3 movementDirection)
    {
        if (movementDirection != Vector3.zero)
        {
            Quaternion toRotation = Quaternion.LookRotation(movementDirection, Vector3.up);
            _model.legs.transform.rotation =
                Quaternion.RotateTowards(_model.legs.transform.rotation, toRotation, (_model.rotationSpeed * 10) * Time.deltaTime);
        }
    }
    
    private void RotateTorso()
    {
        var position = _model.torso.transform.position;
        var forward = _model.torso.transform.forward;
        
        Vector3 targetDelta = (new Vector3(InputManager.Instance.mousePosition.x, position.y, InputManager.Instance.mousePosition.z) - position).normalized;
        float angleToTarget = Vector3.Angle(forward, targetDelta);
        Vector3 turnAxis = Vector3.Cross(forward, targetDelta);

        _model.torso.transform.RotateAround(transform.position, turnAxis, Time.fixedDeltaTime * Mathf.Pow(2, _model.torsoSpeed) * angleToTarget);
        
        // Make sure torso only rotates in Y axis
        var rotation = _model.torso.transform.rotation;
        rotation = new Quaternion(0, rotation.y,0, rotation.w);
        _model.torso.transform.rotation = rotation;
    }
    
    private void OnCollisionExit(Collision other)
    {
        // Enemy
        if (other.gameObject.layer == 8)
            _rb.velocity = Vector3.zero;
    }
    
    /*private IEnumerator Dash(Vector3 direction, float duration, float distance)
    {
        var elapsed = 0f;
        var start = transform.position;
        var target = start + distance * direction;

        // Wall
        int wallLayer = 1 << 7;
        // InvisibleWall
        int invisibleWallLayer = 1 << 14;
        // Sum both layers into one mask
        int layerMask = wallLayer | invisibleWallLayer;
        
        // Check if there's a wall in the middle of the path
        if (Physics.Raycast(transform.position, direction, out var hit, distance, layerMask))
        {
            var offset = 1.5f;
            var newZ = hit.point.z - offset;
            
            if (newZ <= transform.position.z)
                yield break;

            target = new Vector3(hit.point.x, transform.position.y, newZ);
        }

        _canTakeDamage = false;
        
        while (elapsed < duration)
        {
            var iterTarget = Vector3.Lerp (start, target, elapsed / duration);
            transform.position = iterTarget;
            
            elapsed += Time.deltaTime;
            
            yield return new WaitForEndOfFrame();
        }
 
        // Snap there when we finish then update our state
        transform.position = target;

        _canTakeDamage = true;
        _currentDashRate = _model.dashRate;
    }*/

    public void TakeDamage(float damage)
    {
        if (!_canTakeDamage)
            return;
        
        _model.SetCurrentHealth(_model.GetCurrentHealth() - damage);
        
        AudioManager.Instance.Play("PlayerDamaged");
        UIManager.Instance.SetHealth(_model.GetCurrentHealth(), true);
        
        _percentage = (_model.GetCurrentHealth() / _model.hp) * 100;
        if (_percentage <= 40 && !_lowLife)
        {
            EventManager.Instance.Trigger("OnLowLife");
            _lowLife = true;
        }

        if (_model.GetCurrentHealth() <= 0)
        {
            var t = transform;
            Instantiate(_model.corpsePrefab, t.position, Quaternion.LookRotation(t.forward, t.up));
            Instantiate(_model.deathParticles, transform.position + Vector3.up * .5f, Quaternion.identity);
            _model.KillEntity();
        }
    }
    
    public void HealPlayer(float amount)
    {
        _model.SetCurrentHealth(_model.GetCurrentHealth() + amount);

        if (_model.GetCurrentHealth() > _model.hp)
            _model.SetCurrentHealth(_model.hp);
        
        _percentage = (_model.GetCurrentHealth() / _model.hp) * 100;
        if (_percentage > 40 && _lowLife)
        {
            EventManager.Instance.Trigger("OnHighLife");
            _lowLife = false;
        }
        
        UIManager.Instance.SetHealth(_model.GetCurrentHealth(), false);
    }
}
