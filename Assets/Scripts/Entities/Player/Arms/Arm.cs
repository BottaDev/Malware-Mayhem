using System;
using System.Collections;
using System.Collections.Generic;
using System.Linq;
using UnityEngine;
using UnityEngine.AI;

public abstract class Arm : MonoBehaviour, IArm
{
    [Header("General Parameters")] public float speed = 20f;
    public float minAngle = -30;
    public float maxAngle = 180;
    public bool isLeft;
    [Range(min: 0, max: 100)] public float durationTime = 15f;
    [Range(min: 0, max: 100)] public float useDurationLoss = 1f;
    public bool infinitePercentage;

    [Header("Attached Auto-Aim Parameters")]
    public float autoAimArea = 1;
    public float autoAimRange = 10;
    public LayerMask enemyLayerMask;

    /*[Header("Detached Auto-Aim Parameters")]
    public float rotationSpeed = 2f;
    public float detectionRange = 10f;*/
    public LayerMask targetLayerMask;
    public float explosionDamage = 2f;
    public float explosionRadius = 5f;
    public float movingTime = 2f;
    public GameObject explosionParticles;
    public GameObject fireEffect;
    public GameObject flyingParticles;
    //public GameObject rangeIndicator;

    protected float _currentDurationTime;
    protected bool _detached;
    protected PlayerController _controller;
    
    private Vector3 _positionToMove;
    private bool _isMoving;
    private PlayerModel _model;
    private GameObject _target;
    private float _currentMovingTime;
    private Outline _outline;

    protected virtual void Awake()
    {
        _outline = GetComponent<Outline>();
    }

    protected virtual void Start()
    {
        var root = transform.root;

        if (!_detached)
        {
            _currentDurationTime = durationTime;
            _positionToMove = transform.position;
            
            _model = root.GetComponent<PlayerModel>();
            _controller = root.GetComponent<PlayerController>();
        }
    }

    protected virtual void Update()
    {
        CheckLockedPosition();
        Rotate();

        Move();
        
        //AutoAttack();

        ShowParticles();
    }

    private void Move()
    {
        if (!_detached)
            return;
        
        MoveToPosition(_positionToMove);
    }
    
    private void ShowParticles()
    {
        if (!_detached) 
            return;
        
        if (!_isMoving)
        {
            if (!fireEffect.activeSelf)
            {
                fireEffect.SetActive(true);
                flyingParticles.SetActive(false);
            }
        }
        else if (!flyingParticles.activeSelf)
            flyingParticles.SetActive(true);
    }

    private void CheckLockedPosition()
    {
        if (!_detached)
            return;
        
        if (_currentMovingTime > 0)
            _currentMovingTime -= Time.deltaTime;
    }
    
    /*private void AutoAttack()
    {
        if (!_detached || _isMoving)
            return;

        // Only attack when objective is in sight...
        if (Physics.Raycast(transform.position, transform.forward, detectionRange,
            targetLayerMask))
            MakeAction();
    }*/

    protected void SubtractTime(float value)
    {
        if (infinitePercentage)
            return;

        _currentDurationTime -= value;

        if (!_detached)
            UIManager.Instance.SetArmDuration(isLeft, _currentDurationTime);

        /*if (_currentDurationTime <= 0 && _detached && !_isMoving)
            DestroyArm();*/
    }

    public void LaunchArm(float launchDistance, PlayerModel model, PlayerController controller)
    {
        DetachArm();

        // Ensure that the arm can shoot if is being launched
        _controller = _controller == null ? controller : _controller;
        _model = _model == null ? model : _model;
        
        var newPosition = (transform.forward * launchDistance) + transform.position;

        newPosition = GetMiddlePosition(newPosition);

        _positionToMove = newPosition;
        _isMoving = true;
        
        _currentMovingTime = movingTime;
    }

    private void DetachArm()
    {
        _detached = true;

        _outline.enabled = true;
        //rangeIndicator?.SetActive(true);
    }

    private void Rotate()
    {
        /*if (_detached)
            RotateDetached();
        else*/
            RotateAttached();
    }

    /*private void RotateDetached()
    {
        _target = GetClosestEnemy();

        if (_target != null && !_isMoving)
        {
            Vector3 direction = (_target.transform.position - transform.position).normalized;
            Quaternion lookRotation = Quaternion.LookRotation(new Vector3(direction.x, 0, direction.z));
            transform.rotation = Quaternion.Slerp(transform.rotation, lookRotation, Time.deltaTime * rotationSpeed);
        }
    }*/

    /*private GameObject GetClosestEnemy()
    {
        var enemies = Physics.OverlapSphere(transform.position, detectionRange, targetLayerMask).Where(x => x.gameObject.activeSelf);
        var closestEnemy = enemies.OrderBy(n => Vector3.Distance(transform.position, n.transform.position))
            .FirstOrDefault()?.gameObject;

        return closestEnemy;
    }*/

    private void MoveToPosition(Vector3 newPosition)
    {
        if (!_isMoving)
            return;
        
        float distance = Vector3.Distance(newPosition, transform.position);

        if (distance <= 0.1f)
        {
            // Stop movement
            DestroyArm();
            return;
        }

        newPosition = GetMiddlePosition(newPosition);
        
        transform.position = Vector3.MoveTowards(transform.position, newPosition, speed * Time.deltaTime);
        transform.rotation = Quaternion.LookRotation((transform.position - newPosition) * -1);
    }

    private void RotateAttached()
    {
        Vector3 point = InputManager.Instance.mousePosition;
        
        float angle = Vector3.SignedAngle(point - transform.position, _model.torso.transform.forward, Vector3.up); 
        angle *= isLeft ? 1 : -1;
        
        if(angle >= minAngle && angle <= maxAngle)
        {
            var pivotTransform = _model.torso.transform.position;

            Vector3 nextForward = new Vector3(point.x, transform.position.y, point.z) -
                                  new Vector3(transform.position.x, transform.position.y, transform.position.z);
            Vector3 aimTarget = GetAutoAimTarget(nextForward);
            if (aimTarget != Vector3.zero)
            {
                pivotTransform = transform.position;
                point = aimTarget;
            }

            transform.forward = new Vector3(point.x, transform.position.y, point.z) - 
                                new Vector3(pivotTransform.x, transform.position.y, pivotTransform.z);
        }
    }
    
    private Vector3 GetAutoAimTarget(Vector3 nextForward)
    {
        RaycastHit[] posibleTargets = Physics.BoxCastAll(transform.position, Vector3.one * autoAimArea / 2, nextForward, Quaternion.identity, autoAimRange, enemyLayerMask);

        if (posibleTargets.Length > 0)
        {
            float closestDist = 100;
            Vector3 closest = Vector3.zero;
            foreach (var item in posibleTargets)
            {
                float dist = GetDistanceToLine(item.collider.transform.position, transform.position, transform.position + nextForward * autoAimRange);
                if (dist < closestDist)
                {
                    closestDist = dist;
                    closest = item.collider.transform.position;
                }
            }
            
            return closest;
        }

        return Vector3.zero;
    }

    private float GetDistanceToLine(Vector3 a_sourcePoint, Vector3 a_start, Vector3 a_end)
    {
        Vector3 ba = a_end - a_start;
        Vector3 va = a_sourcePoint - a_start;
        Vector3 w2 = va - ((ba * Vector3.Dot(va, ba)) / ba.sqrMagnitude);
        Vector3 pointOnLine = a_sourcePoint - w2;

        return (a_sourcePoint - pointOnLine).magnitude;
    }

    public void ResetDuration()
    {
        _currentDurationTime = durationTime;
    }

    public void SetDurationTime(float time)
    {
        _currentDurationTime = time;
    }

    public float GetDuration()
    {
        return _currentDurationTime;
    }

    private void OnDrawGizmos()
    {
        Gizmos.color = Color.green;
        Gizmos.DrawRay(transform.position + transform.right * autoAimArea/2,  transform.forward * autoAimRange);
        Gizmos.DrawRay(transform.position + transform.right * -autoAimArea/2, transform.forward * autoAimRange);

        Gizmos.color = Color.red;
        Gizmos.DrawWireSphere(transform.position, explosionRadius);
        //Gizmos.DrawRay(_debugAATarget, _debugAATarget + Vector3.up * 3);
        
        /*Gizmos.color = Color.blue;
        Gizmos.DrawWireSphere(transform.position, detectionRange);*/
    }

    private void OnTriggerEnter(Collider other)
    {
        if (other.gameObject.layer == 8 && _detached && _isMoving)
            PushEnemy(other.gameObject.GetComponent<Enemy>());
    }
    
    protected void PushEnemy(Enemy enemy)
    {
        if (_currentDurationTime <= 0)
        {
            DestroyArm();
            return;
        }
        
        enemy.GetPush((enemy.gameObject.transform.position - transform.position).normalized);
    }

    private void DestroyArm()
    {
        Instantiate(explosionParticles, transform.position, Quaternion.identity);
        
        var enemies = Physics.OverlapSphere(transform.position, explosionRadius, targetLayerMask).Select(x => x.GetComponent<Enemy>());
        foreach (var enemy in enemies)
        {
            if (enemy != null)
                enemy.TakeDamage(explosionDamage);
        }
        
        Destroy(gameObject);
    }

    /// <summary>
    /// Returns the position of the middle object if there is one
    /// </summary>
    /// <param name="targetPos"></param>
    /// <returns></returns>
    protected Vector3 GetMiddlePosition(Vector3 targetPos)
    {
        float distance = Vector3.Distance(targetPos, transform.position);
        Vector3 direction = (targetPos - transform.position).normalized;
        
        // Wall
        int layer = 1 << 7;
        
        // Check if there's a wall in the middle of the path
        if (Physics.Raycast(transform.position, direction, out var hit, distance, layer))
            targetPos = new Vector3(hit.point.x, transform.position.y, hit.point.z);
        
        return targetPos;
    }
    
    public virtual void MakeAction() { }
}
