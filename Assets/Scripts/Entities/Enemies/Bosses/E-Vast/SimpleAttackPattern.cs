using MM.Common;
using UnityEngine;

namespace MM.Entities.Enemies.Bosses.E_Vast
{
    public class SimpleAttackPattern : SubmoduleAttack
    {
        #region Private Variables
        [Header("Pattern Parameters")]
        [SerializeField] private string patternName;
        [SerializeField] private BossBulletType projectile = BossBulletType.MediumGreen;
        [SerializeField, Range(0, 100)] private int numberOfProjectiles;
        [SerializeField, Range(0.1f, 1f)] private float fireRate = 0.1f;
        [SerializeField, Range(0f, 10f)] private float radius;
        [SerializeField, Range(0f, 360f)] private float rotationPerSecond = 90;
        [SerializeField] private float patternDuration = 2f;
        [SerializeField] private bool changeDirection;

        private const float _maxAngle = 360f;
        private float _currentFireRate = 0;
        private float _accumulatedRotation;
        private bool _isActive;
        #endregion
    
        #region MonoBehaviour Functions
        private void Update()
        {
            if (_boss.GetHp() <= 0 || !_isActive || !_canAttack)
                return;

            if (_currentFireRate <= 0)
                SpawnBullets();
            else
                _currentFireRate -= Time.deltaTime;
        
            AccumulateRotation();
        }
        #endregion
    
        #region Private Functions
        private void AccumulateRotation()
        {
            _accumulatedRotation += Time.deltaTime * rotationPerSecond;
            if (_accumulatedRotation >= _maxAngle)
                _accumulatedRotation  = 0;
        }
        
        private void SpawnBullets()
        {
            var angle = _maxAngle / numberOfProjectiles;

            for (var i = 0; i < numberOfProjectiles; i++)
            {
                if (_submodule.GetIsStunned())
                {
                    _currentFireRate = fireRate;
                    return;
                }
            
                var rotation = !changeDirection ? 
                    Quaternion.AngleAxis(i * angle + _accumulatedRotation, Vector3.up) : 
                    Quaternion.AngleAxis(i * angle - _accumulatedRotation, Vector3.up);

                var direction = rotation * Vector3.forward;
                var position = transform.position + (direction * radius);

                // Fix the Y of the spawn
                const float yAxis = 1.72f;
            
                position = new Vector3(position.x, yAxis, position.z);
            
                var bullet = EnemyPoolManager.Instance.GetBossBullet(projectile);
                bullet.transform.position = position;
                bullet.transform.rotation = rotation;
            }
        
            _currentFireRate = fireRate;
        }
    
        private void StopPattern()
        {
            _isActive = false;
        }
        #endregion
    
        #region Public Functions
        public override void MakeAction()
        {
            base.MakeAction();
            if (_boss.GetHp() <= 0)
                return;

            _isActive = true;
            _currentFireRate = 0;
        
            Invoke(nameof(StopPattern), patternDuration);
        }
        #endregion
    }
}