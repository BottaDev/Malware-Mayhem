using System.Collections;
using System.Linq;
using MM.Common;
using UnityEngine;

namespace MM.Entities.Enemies
{
    public class Shielder : Enemy
    {
        [Header("Shielder Parameters")] 
        [SerializeField]private float minFireRate = 4f;
        [SerializeField]private float maxFireRate = 5f;
        [SerializeField]private float attackRate = 12f;
        [SerializeField]private float waitTime = 1f;
        [SerializeField]private float attackDistance = 10;
        [SerializeField]private float searchDistance = 200f;
        [SerializeField]private LayerMask shieldMask;
        [SerializeField]private GameObject shield;
    
        private Enemy _target;
        private LaserPorter _laserPorter;
        private float _fireRate;
        private float _currentFireRate;
        private float _currentAttackRate;

        protected override void Awake()
        {
            base.Awake();
        
            _fireRate = Random.Range(minFireRate, maxFireRate);
            _currentAttackRate = attackRate;
            SearchTarget();
        }

        private void SearchTarget()
        {
            var totalEnemies = Physics.OverlapSphere(transform.position, searchDistance, shieldMask).Select(x => x.GetComponent<Enemy>());
            // Get enemies that are not Shielder type
            var enemies = totalEnemies.Where(x => x.GetType() != EnemyType.Shielder);
            // Get enemies that are been protected by Shielders
            var enemiesProtected = totalEnemies.Where(x => x.GetType() == EnemyType.Shielder).Select(x => x.GetComponent<Shielder>().GetTarget());
        
            // Get nearest enemy that is not been protected by a Shielder 
            _target = enemies
                .Where(x => !enemiesProtected.Contains(x))
                .OrderBy(n => Vector3.Distance(transform.position, n.transform.position))
                .FirstOrDefault();
        }

        protected override void MakeActions()
        {
            CheckAttackRate();

            if (_target == null)
            {
                if (_currentFireRate <= 0 && _distanceToPlayer <= attackDistance &&
                    !_fov.CheckMiddleObstacle(_player.transform.position))
                    Attack();
                else
                    _currentFireRate -= Time.deltaTime;
            
                return;
            }
        
            CheckTargetType();
        }

        /// <summary>
        /// Check if Shielder should pass to attack mode
        /// </summary>
        private void CheckAttackRate()
        {
            if (_currentAttackRate <= 0 && _distanceToPlayer <= attackDistance)
            {
                _target = null;
                _currentAttackRate = attackRate;
            }
            else
            {
                _currentAttackRate -= Time.deltaTime;
            }
        }
    
        private void Attack()
        {
            StartCoroutine(SpawnShoot());
            _currentFireRate = _fireRate;
        }
    
        private IEnumerator SpawnShoot()
        {
            shield.SetActive(false);
        
            var shieldBullet = EnemyPoolManager.Instance.shieldBulletPool.Get();
            shieldBullet.pool = EnemyPoolManager.Instance.shieldBulletPool;
            shieldBullet.transform.position = shield.transform.position;
            shieldBullet.transform.eulerAngles = transform.eulerAngles;
        
            yield return new WaitForSeconds(waitTime);
        
            if (!GetIsStunned())
                shield.SetActive(true);
            SearchTarget();
        }

        private void CheckTargetType()
        {
            if (_target.GetType() == EnemyType.LaserPorter)
            {
                _laserPorter = _laserPorter == null ? _target.GetComponent<LaserPorter>() : _laserPorter;
                if (!_laserPorter.GetVisibility())
                {
                    // Should change enemy
                    _target = null;
                    _laserPorter = null;
                }
            }
        }
    
        protected override void Move()
        {
            if (_target == null)
            {
                if (_distanceToPlayer > attackDistance || _fov.CheckMiddleObstacle(_player.transform.position))
                    ChasePlayer();
                else
                    StayIdle();
            }
            else
            {
                MoveWithTarget();    
            }
        }

        private void MoveWithTarget()
        {
            if (_agent.enabled)
                _agent.isStopped = false;
        
            var position = _player.transform.position;
        
            if (!_fov.CheckMiddleObstacle(position) || 
                !_target.GetFov().CheckMiddleObstacle(position))
                DefendTarget();
            else
                FollowTarget();
        }
    
        private void StayIdle()
        {
            if (_agent.enabled)
                _agent.isStopped = true;

            RotateTowards(_player.transform.position);
        }
    
        private void ChasePlayer()
        {
            if (_agent.enabled)
                _agent.isStopped = false;

            var position = _player.transform.position;
            MoveToPosition(position);
            RotateTowards(position);
        }
    
        private void FollowTarget()
        {
            _agent.stoppingDistance = 2;

            var position = _target.transform.position;
            MoveToPosition(position);
            RotateTowards(position);
        }
    
        private void DefendTarget()
        {
            _agent.stoppingDistance = 0;
        
            Vector3 medianPoint = Vector3.Lerp(_target.transform.position, _player.transform.position, .35f);
            MoveToPosition(medianPoint);
            RotateTowards(_player.transform.position);
        }
    
        protected override IEnumerator StunEnemy()
        {
            absorbImg.SetActive(true);
            shield.SetActive(false);
            yield return base.StunEnemy();
            shield.SetActive(true);
            absorbImg.SetActive(false);
        }

        public Enemy GetTarget()
        {
            return _target;
        }
    
        private void OnDrawGizmosSelected()
        {
            Gizmos.color = Color.red;
            Gizmos.DrawWireSphere(transform.position, attackDistance);
        
            Gizmos.color = Color.green;
            Gizmos.DrawWireSphere(transform.position, searchDistance);
        }
    }
}
