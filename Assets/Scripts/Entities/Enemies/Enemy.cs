using System.Collections;
using Sound;
using UnityEngine;
using UnityEngine.AI;
using UnityEngine.Serialization;
using Random = UnityEngine.Random;

[RequireComponent(typeof(FOV))]
public abstract class Enemy : Entity
{
    [Header("Enemy Parameters")]
    public EnemyType type;
    [SerializeField, Range(0, 100)] private float stunPercentageChance = 50f;
    [SerializeField] private float stunTime = 5f;
    [Tooltip("The percentage that the enemy recovers when leaving the stun state")]
    [SerializeField, Range(1, 100)] private float recoveryPercentage = 30f;

    protected PlayerModel _player;
    protected NavMeshAgent _agent;
    protected CameraShaker _cameraShaker;
    protected float _distanceToPlayer;
    protected float _currentMovementSpeed;
    
    public bool isStunned;
    public bool forceStun;
    [SerializeField] private bool cantStun;
    [SerializeField] private bool cantRecover;
    [SerializeField] private bool cantDie;
    private  bool _isDead;
    private bool _isInvulnerable;
    private bool _wasStunned;
    private Rigidbody _rb;
    protected FOV _fov;
    private bool _onTransition;  // Used to stop the movement when the enemy is dying on scene transition (modules)
    
    [Space(15)]
    [SerializeField] protected GameObject corpsePrefab;
    [SerializeField] protected GameObject deathParticles;
    [SerializeField] protected GameObject stunnedParticles;
    [SerializeField] protected GameObject onStunParticles;
    public AbsorptionParticles absortionParticles;
    [SerializeField] protected GameObject absorbImg;
    [SerializeField] protected Material[] stunnedMaterials;

    protected override void Awake()
    {
        base.Awake();
        
        _agent = GetComponent<NavMeshAgent>();
        _rb = GetComponent<Rigidbody>();
        _fov = GetComponent <FOV>();
        _cameraShaker = GetComponent<CameraShaker>();
        
        absorbImg.SetActive(false);
        _currentMovementSpeed = movementSpeed;
    }
    
    private void Start()
    {
        EventManager.Instance.Subscribe(EventManager.NameEvent.OnAbsorbedSubmodule, OnAbsorbedSubmodule);
        EventManager.Instance.Subscribe(EventManager.NameEvent.OnBossDeath, OnBossDeath);
    }

    public virtual void Update()
    {
        if (CheckPlayer() || PauseManager.Instance.isPaused)
            return;
        
        SetAISpeed();

        _distanceToPlayer = Vector3.Distance(transform.position, _player.transform.position);

        if (!isStunned)
        {
            Move();
            MakeActions();   
        }
    }

    /// <summary>
    /// Check if the player exists in the level
    /// </summary>
    /// <returns></returns>
    private bool CheckPlayer()
    {
        if (_player == null)
            _player = LevelManager.Instance.GetPlayer();

        return _player == null;
    }
    
    private void SetAISpeed()
    {
        _agent.speed = _currentMovementSpeed;
    }

    protected void RotateTowards (Vector3 target) 
    {
        Vector3 direction = (target - transform.position).normalized;
        Quaternion lookRotation = Quaternion.LookRotation(new Vector3(direction.x, 0, direction.z));
        transform.rotation = Quaternion.Slerp(transform.rotation, lookRotation, Time.deltaTime * rotationSpeed);
    }
    
    protected void MoveToPosition(Vector3 position)
    {
        if (_onTransition ||
            _agent.destination == Vector3.positiveInfinity)
        {
            return;   
        }

        _agent.destination = position;
    }
    
    protected virtual void Move() { }
    
    protected virtual void MakeActions() { }

    private void OnCollisionExit(Collision other)
    {
        // Enemy, Player
        if (other.gameObject.layer is 8 or 9)
            _rb.velocity = Vector3.zero;
    }

    public override void TakeDamage(float damage, PlayerArm.ArmType aType = PlayerArm.ArmType.None, bool showDamage = true)
    {
        if (_isInvulnerable)
            return;
     
        if(showDamage)
            StartCoroutine(ShowDamage());
        
        _currentHp -= damage;
        
        AudioManager.Instance.PlayAudioClip(Sounds.SoundType.EnemyDamaged, transform.position);

        if (_currentHp <= 0 && !_wasStunned && (Random.value < stunPercentageChance * 0.01f) && !cantStun)
        {
            EventManager.Instance.Trigger(EventManager.NameEvent.OnStunnedEnemy);
            StartCoroutine(StunEnemy());   
        }
        else if (_currentHp <= 0 && !_isDead && !cantDie)
        {
            var transform1 = transform;
            Instantiate(corpsePrefab, transform1.position, Quaternion.LookRotation(transform1.forward, transform1.up));
            Instantiate(deathParticles, transform.position + Vector3.up * .5f, Quaternion.identity);
            KillEntity();
        }
    }

    protected virtual IEnumerator StunEnemy()
    {
        _isInvulnerable = true;
        absorbImg.gameObject.SetActive(true);
        _wasStunned = true;
        isStunned = true;
        _currentMovementSpeed = 0;
        
        if (_agent.enabled)
            _agent.isStopped = true;

        const float resetTime = 1f;
        Invoke(nameof(ResetInvulnerability), resetTime);
        
        Instantiate(onStunParticles, transform.position, Quaternion.identity);
        var ps = Instantiate(stunnedParticles, transform);
        ps.transform.localPosition = transform.up;
        
        // Ensure that the player can merge the enemy while it's stunned...
        if (forceStun)
            yield break;
        
        if(cantRecover)
            yield break;
        
        yield return new WaitForSeconds(stunTime);

        // Ensure that the player can merge the enemy while it's stunned...
        if (forceStun)
            yield break;
        
        for (var i = 0; i < allRenderers.Length; i++)
            allRenderers[i].material = baseMats[i];
        
        Destroy(ps);
        absorbImg.gameObject.SetActive(false);

        if(_agent.enabled)
            _agent.isStopped = false;

        RecoverFromStun();
    }
    
    /// <summary>
    /// Ensure that the enemy is stunned when the player merge
    /// </summary>
    public void ForceStun()
    {
        forceStun = true;
    }

    protected virtual void RecoverFromStun()
    {
        // Ensure that the player can merge the enemy while it's stunned...
        if (forceStun)
            return;
        
        isStunned = false;
        
        ResetMovementSpeed();
        
        var newHp = (recoveryPercentage * hp) / 100;
        _currentHp = newHp;
    }
    
    private void ResetInvulnerability()
    {
        _isInvulnerable = false;
    }
    
    public override void KillEntity()
    {
        _cameraShaker.ShakeCamera();
        
        _isDead = true;
        EventManager.Instance.Trigger(EventManager.NameEvent.OnEnemyDead, type);
        
        AudioManager.Instance.PlayAudioClip(Sounds.SoundType.EnemyDead, transform.position);
        base.KillEntity();
    }

    protected override IEnumerator ShowDamage()
    {
        foreach (var item in allRenderers)
            item.material = damagedMat;

        yield return new WaitForSeconds(.1f);

        for (var i = 0; i < allRenderers.Length; i++)
            allRenderers[i].material = isStunned ? stunnedMaterials[i] : baseMats[i];
    }
    
    public bool GetIsStunned()
    {
        return isStunned;
    }

    public FOV GetFov()
    {
        return _fov;
    }

    private void ResetMovementSpeed()
    {
        _currentMovementSpeed = movementSpeed;
    }
    
    private void OnAbsorbedSubmodule(params object[] parameters)
    {
        _onTransition = true;
    }

    /// <summary>
    /// Should kill the enemy when the boss dies
    /// </summary>
    /// <param name="parameters"></param>
    private void OnBossDeath(params object[] parameters)
    {
        if (_isDead || 
            this == null || 
            !gameObject.activeInHierarchy)
            return;

        const float time = 0.3f;
        Invoke(nameof(KillEnemyByTime), time);
    }
    
    /// <summary>
    /// Should be called only when the boss is killed
    /// </summary>
    private void KillEnemyByTime()
    {
        var transform1 = transform;
        Instantiate(corpsePrefab, transform1.position, Quaternion.LookRotation(transform1.forward, transform1.up));
        Instantiate(deathParticles, transform.position + Vector3.up * .5f, Quaternion.identity);
        
        KillEntity();
    }
    
    public enum EnemyType
    {
        LaserPorter,
        AssaultBox,
        Shielder,
        Blader
    }
}
