using MM.Common;
using UnityEngine;
using Random = UnityEngine.Random;

namespace MM.Entities.Enemies.Bosses.Iset
{
    public class IsetHookIn : SubmoduleAttack
    {
        #region Private Variables
        [Header("Hook Parameters")]
        [SerializeField] private float hookDamage = 10f;
        [SerializeField] private float timeBeforeHook = 1.5f;
        [Tooltip("The distance that the boss must reach to shoot all the bullets")]
        [SerializeField] private float hookDistance = 1f;
        [Space]
        [Header("Bullet Parameters")]
        [SerializeField] private BossBulletType typeOfBulletToDivide;
        [SerializeField] private int numberOfBulletsToDivide = 20;
        
        private IsetMobilizer _mobilizer;
        private BossArm _arm;
        private Vector3 _hookPos;
        private bool _hookShot;
        #endregion
        
        #region MonoBehaviour Functions
        protected override void Start()
        {
            base.Start();
            _mobilizer = GetComponentInParent<IsetMobilizer>();
            _arm = GetComponentInChildren<BossArm>();
        }
        private void Update()
        {
            CheckHook();
        }
        #endregion
        
        #region Prviate Functions

        private void CheckHook()
        {
            var position = _mobilizer.gameObject.transform.position;
            var hookPos = new Vector3(_hookPos.x, position.y, _hookPos.z);
            
            if (_hookShot && 
                Vector3.Distance(position, hookPos) <= hookDistance)
            {
                _hookShot = false;
                _arm.SetLookAtObject(false);
                
                SpawnBullets();
            }
        }
        
        /// <summary>
        /// Spanws the bullets in a circle around the boss
        /// </summary>
        private void SpawnBullets()
        {
            const float angleRange = 360f;
            var angleStep = angleRange / numberOfBulletsToDivide;

            for (var i = 0; i < numberOfBulletsToDivide; i++)
            {
                var currentAngle = i * angleStep + Random.Range(0f, 360f);
                var rotation = Quaternion.AngleAxis(currentAngle, Vector3.up);

                var direction = rotation * Vector3.forward;
                var position = transform.position + direction;

                // Fix the Y of the spawn
                const float yAxis = 1f;
            
                position = new Vector3(position.x, yAxis, position.z);

                var bullet = EnemyPoolManager.Instance.GetBossBullet(typeOfBulletToDivide);

                var bulletTransform = bullet.transform;
                bulletTransform.position = position;
                bulletTransform.rotation = rotation;
            }
            
            // Restore the normal movement
            _mobilizer.SetMovingToHook(false);
            _mobilizer.RestartMovement();
        }

        private void ShootHook()
        {
            _mobilizer.SetMovingToHook(true);
            
            // Wall mask
            const int layerMask = 1 << 7;
            
            if (!Physics.Raycast(transform.position, transform.forward, out var hit, 999f, layerMask)) 
                return;
            
            var hook = new GameObject("HookPos")
            {
                transform =
                {
                    position = hit.point,
                    rotation = Quaternion.identity
                }
            };
                
            _arm.SetLookAtObject(hook);
            _hookShot = true;
            _hookPos = hook.transform.position;
            
            _mobilizer.MoveToHook(hook.transform.position);
        }
        #endregion
        
        #region Public Functions
        public override void MakeAction()
        {
            base.MakeAction();
            
            _arm.SetLookAtObject(true);
            
            Invoke(nameof(ShootHook), timeBeforeHook);
        }
        #endregion
    }
}
