using System.Collections;
using MM.Common;
using MM.Sound;
using UnityEngine;

namespace MM.Entities.Enemies
{
    public class AssaultBox : Enemy
    {
        #region Private Variables
        [Header("AssaultBox Parameters")]
        [SerializeField] private float minFireRate = 2f;
        [SerializeField] private float maxFireRate = 3f;
        [SerializeField] private int shotsCount = 3;
        [SerializeField] private float timeBetweenShot = 0.1f;
        [SerializeField] private float attackDistance;
        [SerializeField] private float idealDistance;
        [SerializeField] private float upperBodySpeed;
        [SerializeField] private bool cantMove;
        [SerializeField] private bool cantAttack;

        [Header("AssaultBox Objects")]
        [SerializeField] private GameObject upperBody;
        [SerializeField] private Transform shotSpawn;

        private float _fireRate;
        private float _currentFireRate;
        private bool _attacking = false;
        private Vector3 _moveDirection;
        private Animator _animator;
        private static readonly int IsMoving = Animator.StringToHash("IsMoving");

        #endregion

        #region MonoBehaviour Functions
        protected override void Awake()
        {
            base.Awake();
            
            _fireRate = Random.Range(minFireRate, maxFireRate);
            _animator = GetComponent<Animator>();
        }
        #endregion

        #region Private Functions
        private void StayIdle()
        {
            if (_agent.enabled)
                _agent.isStopped = true;

            var position = _player.transform.position;
            RotateTowards(position);
            RotateUpperBody(position);
        }

        private void RotateUpperBody(Vector3 target)
        {
            var direction = (target - upperBody.transform.position).normalized;
            var lookRotation = Quaternion.LookRotation(new Vector3(direction.x, 0, direction.z));
            
            //The -90 is to make the upper body look at the player because of the rotation of the model
            upperBody.transform.rotation = Quaternion.Slerp(upperBody.transform.rotation,
                                         Quaternion.Euler(-90, lookRotation.eulerAngles.y, lookRotation.eulerAngles.z),
                                         Time.deltaTime * upperBodySpeed);
        }

        private IEnumerator SpawnShoot()
        {
            _attacking = true;

            for (var i = 0; i < shotsCount; i++)
            {
                if (isStunned)
                    break;

                var position = shotSpawn.position;
            
                var bullet = EnemyPoolManager.Instance.assaultBulletPool.Get();
                bullet.pool = EnemyPoolManager.Instance.assaultBulletPool;
                
                var bulletTransform = bullet.transform;
                bulletTransform.position = position;
                
                var eulerAngles = upperBody.transform.eulerAngles;
                
                //Need this to make the bullet look at the player because of the rotation of the model
                var rotation = new Vector3(0, eulerAngles.y, eulerAngles.z);
                
                bulletTransform.eulerAngles = rotation;
            
                AudioManager.Instance.PlayAudioClip(Sounds.SoundType.EnemyBlueShot, position);

                yield return new WaitForSeconds(timeBetweenShot);
            }

            _attacking = false;
            _moveDirection = CalculateNextDirection();
        }

        private void Attack()
        {
            if(cantAttack)
            {
                _moveDirection = CalculateNextDirection();
                return;
            }
        
            StartCoroutine(SpawnShoot());
            _currentFireRate = _fireRate;
        }

        protected override void MakeActions()
        {
            if (_currentFireRate <= 0 && _distanceToPlayer <= attackDistance &&
                !_fov.CheckMiddleObstacle(_player.transform.position))
                Attack();
            else
                _currentFireRate -= Time.deltaTime;
        }

        protected override void Move()
        {
            if (_attacking || cantMove)
            {
                _animator.SetBool(IsMoving, false);
                StayIdle();
                return;
            }

            _animator.SetBool(IsMoving, true);
            if (_distanceToPlayer >= attackDistance || _fov.CheckMiddleObstacle(_player.transform.position))
                MoveToPosition(_player.transform.position);
            else
                MoveToPosition(transform.position + _moveDirection);

            RotateTowards(transform.position + _moveDirection);
            RotateUpperBody(_player.transform.position);
        }

        private Vector3 CalculateNextDirection()
        {
            var newPos = transform.position;
        
            if (_player != null)
                newPos = _player.transform.position;
        
            if (_agent.enabled)
                _agent.isStopped = false;
        
            var nextDir = (_distanceToPlayer >= idealDistance ? newPos - transform.position : transform.position - newPos).normalized;

            return nextDir;
        }
        #endregion

        #region Events
        private void OnDrawGizmosSelected()
        {
            Gizmos.color = Color.red;
            Gizmos.DrawWireSphere(transform.position, attackDistance);
        }
        #endregion
    }
}