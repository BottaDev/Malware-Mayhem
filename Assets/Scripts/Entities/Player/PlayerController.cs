using System;
using System.Collections;
using System.Linq;
using UnityEngine;
using UnityEngine.SceneManagement;
using Random = UnityEngine.Random;

public class PlayerController : MonoBehaviour
{
    public Pool<Bullet> bulletPool;
    public Pool<Bullet> assaultBulletPool;
    public Pool<Bullet> shieldBulletPool;

    private const float _pullDown = 0.1f; // dimensionless > 0, < 1
    private float _horizontalMovement;
    private float _verticalMovement;
    private float _currentSpeed;
    private float _maxOverSpeed;
    private float _percentage;
    private int _submoduleIndex;
    private bool _leftArmToChange = true;
    private bool _inMergeTransition;    // Used to prevent the player from moving while merging
    private bool _isAbsorbing;
    private bool _lowLife;
    private bool _cantInteract;
    private bool _cantHeal;
    private bool _cantChangeArm;
    private bool _canTakeDamage = true;
    private bool _canShoot = true;  // If player can shoot
    private bool _godModeDisable = true;  // If player can take damage (GOD MODE)   TODO: Remove this
    private PlayerArm _currentLeftArm;
    private PlayerArm _currentRightArm;
    private PlayerModel _model;
    private PlayerView _view;
    private Rigidbody _rb;
    private Enemy _closeEnemy;
    private BossSubmodule _hackedSubmodule;
    private Camera _cam;
    private Collider _collider;
    private ParticleSystemForceField _lastForceField;   // The last force field that the player spawned
    private Vector3 _lastNewPosition;   // The last position where the player appeared from the submodule fight

    private static bool IsPaused => PauseManager.Instance.isPaused;

    private void Awake()
    {
        _model = GetComponent<PlayerModel>();
        _view = GetComponent<PlayerView>();
        _rb = GetComponent<Rigidbody>();
        _cam = Camera.main;

        _maxOverSpeed = _model.movementSpeed + 1;
        
        _collider = GetComponent<Collider>();
    }

    private void Start()
    {
        SetStartingArm();
        
        // Set HP 
        UIManager.Instance.SetMaxHealth(_model.hp, true);
        
        EventManager.Instance.Subscribe(EventManager.NameEvent.OnReturnedBoss, OnReturnedBoss);
        EventManager.Instance.Subscribe(EventManager.NameEvent.OnTextStarted, OnTextStarted);
        EventManager.Instance.Subscribe(EventManager.NameEvent.OnTextFinished, OnTextFinished);

        CreatePools();
    }

    private void SetStartingArm()
    {
        var armIndex = _model.startingArm switch
        {
            PlayerArm.ArmType.BasicArm => 0,
            PlayerArm.ArmType.LaserArm => 1,
            PlayerArm.ArmType.BurstArm => 2,
            PlayerArm.ArmType.ShieldArm => 3,
            PlayerArm.ArmType.BladeArm => 4,
            _ => 0
        };

        SetArm(true, armIndex);
        SetArm(false, armIndex);
    }
    
    private void CreatePools()
    {
        var poolTransform = GameObject.Find("Pool").GetComponent<Transform>();
        if (poolTransform == null)
            Debug.LogError("Pool Object not found in scene");
        
        var basicBulletFactory = new BasicBulletFactory(poolTransform);
        bulletPool = new Pool<Bullet>(basicBulletFactory.Create, Bullet.TurnOn, Bullet.TurnOff, 6);
        
        var assaultBulletFactory = new PlayerAssaultBulletFactory(poolTransform);
        assaultBulletPool = new Pool<Bullet>(assaultBulletFactory.Create, Bullet.TurnOn, Bullet.TurnOff, 6);
        
        var shieldBulletFactory = new PlayerShieldBulletFactory(poolTransform);
        shieldBulletPool = new Pool<Bullet>(shieldBulletFactory.Create, Bullet.TurnOn, Bullet.TurnOff, 1);
    }
    
    public void Update()
    {
        if(IsPaused || _inMergeTransition) 
            return;

        if (_isAbsorbing)
        {
            ProcessMerge();
            
            var timeScaleT = _model.timeScaleSpeed * Time.unscaledDeltaTime;
            var fovT = _model.camZoomSpeed * Time.unscaledDeltaTime;
            
            SetTimeScale(Time.timeScale, _model.timeScaleSlow, timeScaleT, _cam.fieldOfView, _model.minCamFOV, fovT);
        }
        else
        {
            ProcessActions();
            
            var timeScaleT = _model.timeScaleSpeed * 2 * Time.unscaledDeltaTime;
            var fovT = _model.camZoomSpeed * 2 * Time.unscaledDeltaTime;
            
            SetTimeScale(Time.timeScale, 1, timeScaleT, _cam.fieldOfView, _model.maxCamFOV, fovT);
        }
    }

    private void ProcessActions()
    {
        if(_cantInteract) return;
        
        PauseManager.Instance.isPlayerAbsorbing = false;
        if (Input.GetMouseButton(0) || Input.GetMouseButtonDown(0))
        {
            if (_currentLeftArm.GetDuration() <= 0)
                StartCoroutine(ResetToBasicArm(true));
            else
                UseArm(true);
        }

        if (Input.GetMouseButton(1) || Input.GetMouseButtonDown(1))
        {
            if (_currentRightArm.GetDuration() <= 0)
                StartCoroutine(ResetToBasicArm(false));
            else
                UseArm(false);
        }
            
        if (Input.GetKeyDown(KeyCode.Space))
            CheckStunnedEntity();
            
        if (Input.GetKeyDown(KeyCode.T))
            RemoveTutorial();
        
        if (Input.GetKeyDown(KeyCode.G))
            SetGodMode();
    }


    private bool _eventTriggered = false;
    private void ProcessMerge()
    {
        _canShoot = false;
        PauseManager.Instance.isPlayerAbsorbing = true;
        if (Vector3.Distance(transform.position, _closeEnemy.transform.position) > _model.absorbDistance ||
            !_closeEnemy.isStunned)
            ResetAbsorbing(false);

        if(!_eventTriggered)
        {
            EventManager.Instance.Trigger(EventManager.NameEvent.OnAbsorbingEnemy);
            _eventTriggered = true;
        }
        
        if(_cantInteract) return;
        
        if (Input.GetKeyDown(KeyCode.Q) || Input.GetMouseButtonDown(0))
        {
            if(_cantChangeArm) return;
            
            AudioManager.Instance.PlayAudioClip(Sounds.SoundType.AbsorbEnemy, transform.position);
            
            _closeEnemy.KillEntity();
            SetArmToChange(_closeEnemy.type, true);
                
            ResetAbsorbing();
        }
        else if (Input.GetKeyDown(KeyCode.E) || Input.GetMouseButtonDown(1))
        {
            if(_cantChangeArm) return;
            
            AudioManager.Instance.PlayAudioClip(Sounds.SoundType.AbsorbEnemy, transform.position);

            _closeEnemy.KillEntity();
            SetArmToChange(_closeEnemy.type, false);

            ResetAbsorbing();
        }
        else if (Input.GetKeyDown(KeyCode.Space) && !_cantHeal)
        {
            HealPlayer(_model.healAmount);
            _closeEnemy.KillEntity();
             
            ResetAbsorbing();
        }
    }

    /// <summary>
    /// Set the time scale and the camera FOV when the player is absorbing an enemy
    /// </summary>
    /// <param name="timeScaleA"></param>
    /// <param name="timeScaleB"></param>
    /// <param name="timeScaleT"></param>
    /// <param name="fovA"></param>
    /// <param name="fovB"></param>
    /// <param name="fovT"></param>
    private void SetTimeScale(float timeScaleA, float timeScaleB, float timeScaleT, float fovA, float fovB, float fovT)
    {
        Time.timeScale = Mathf.Lerp(timeScaleA, timeScaleB, timeScaleT);
        _cam.fieldOfView = Mathf.Lerp(fovA, fovB, fovT);
    }

    private void ResetAbsorbing(bool absorbed = true)
    {
        _isAbsorbing = false;
        _canTakeDamage = false;
        _eventTriggered = false;
        
        if (absorbed)
        {
            const float timeToResetShooting = 0.2f;
            Invoke(nameof(ResetShooting), timeToResetShooting);
        }
        else
        {
            ResetShooting();   
        }

        const float time = 0.5f;
        Invoke(nameof(SetInvulnerability), time);
    }
    
    private void SetInvulnerability()
    {
        _canTakeDamage = true;
    }
    
    private void ResetShooting()
    {
        _canShoot = true;
    }
    
    // TODO: Set only for EDITOR
    private void SetGodMode()
    {
        _godModeDisable = !_godModeDisable;
    }
    
    private static void RemoveTutorial()
    {
        EventManager.Instance.Trigger(EventManager.NameEvent.OnTutorialSkip);
    }
    
    /// <summary>
    /// Set the arm to the basic arm
    /// </summary>
    /// <param name="isLeft"></param>
    private IEnumerator ResetToBasicArm(bool isLeft)
    {
        Invoke(isLeft ? nameof(ResetLeftArm) : nameof(ResetRightArm) , _model.armResetTime);
        
        const float timeToResetShooting = 0.1f;
        yield return new WaitForSeconds(timeToResetShooting);
        
        PlayerView.ResetArm(isLeft ? _currentLeftArm : _currentRightArm);
    }
    
    private void ResetLeftArm()
    {
        SetArm(true, 0);
    }

    private void ResetRightArm()
    {
        SetArm(false, 0);
    }

    private void UseArm(bool left)
    {
        if (IsPaused || !_canShoot || _cantInteract) 
            return;
        
        if (left)
            _currentLeftArm.MakeAction();
        else
            _currentRightArm.MakeAction();
    }
    
    /// <summary>
    /// Check if there's a submodule in the player's range to absorb
    /// </summary>
    private void CheckStunnedEntity()
    {
        var modules = Physics.OverlapSphere(transform.position, _model.absorbDistance, _model.moduleAbsorbMask)
            .Select(x => x.GetComponent<BossSubmodule>()).ToList();
        
        var closeModule = modules.Where(x=> x.GetIsStunned())
            .OrderBy(x => Vector2.Distance(transform.position, x.transform.position))
            .ToList()
            .FirstOrDefault();

        if (closeModule != null && !_isAbsorbing && !closeModule.wasAbsorbed)
        {
            closeModule.wasAbsorbed = true;
            _hackedSubmodule = closeModule;
            _submoduleIndex = closeModule.submoduleIndex;

            var scene = SceneManager.GetActiveScene();
            if (scene.name == "Tutorial")
            {
                SceneManager.LoadScene("Notron");
            }
            else
            {
                StartCoroutine(ChangeSubmodule(_submoduleIndex));
            }
            
            return;
        }

        CheckStunnedEnemy();
    }

    /// <summary>
    /// Check if there's a enemy in the player's range to absorb
    /// </summary>
    private void CheckStunnedEnemy()
    {
        var enemies = Physics.OverlapSphere(transform.position, _model.absorbDistance, _model.enemyAbsorbMask)
            .Select(x => x.GetComponent<Enemy>()).ToList();
        
        // Is the boss...
        if (enemies.Count == 1 && enemies.First() == null)
            return;

        _closeEnemy = enemies.Where(enemy => enemy != null && enemy.GetIsStunned())
            .OrderBy(x => Vector2.Distance(transform.position, x.transform.position))
            .ToList()
            .FirstOrDefault();

        if (_closeEnemy != null && !_isAbsorbing)
            StartCoroutine(StartMergeEnemy());
    }
    
    private IEnumerator StartMergeEnemy()
    {
        _closeEnemy.ForceStun();
        
        StartMergeAnimation(false);
        
        const float waitTime = 1f;
        yield return new WaitForSeconds(waitTime);

        // Allow the player to process input again
        _inMergeTransition = false;
        
        _isAbsorbing = true;
        UIManager.Instance.ToggleAbsorbMenu(true);
        
        _closeEnemy.ForceStun();
        
        // Get the position of the enemy to merge
        var newPos = _closeEnemy.transform.position;
        
        yield return new WaitWhile(() => _isAbsorbing);
        
        // Reset the close enemy
        _closeEnemy = null;
        
        UIManager.Instance.ToggleAbsorbMenu(false);

        EndMergeAnimation(newPos);
    }

    /// <summary>
    /// Show the animation for the player when hack / merge
    /// </summary>
    private void StartMergeAnimation(bool isSubmodule)
    {
        ResetPlayerMovement();
        
        var forceField = isSubmodule ? _hackedSubmodule.GetParticleForceField() : _closeEnemy.GetParticleForceField();
        _view.ShowMergingEffect(forceField);
        
        _view.SetPlayerVisibility(false);
        
        _inMergeTransition = true;
        
        // Don't let the player receive damage while merging
        _collider.enabled = false;
    }

    /// <summary>
    /// End the animation for the player when hack / merge
    /// </summary>
    private void EndMergeAnimation(Vector3 newPos)
    {
        // Set the player position in the same position of the enemy
        transform.position = new Vector3(newPos.x, transform.position.y, newPos.z);
        
        // Allow the player to process input again
        _inMergeTransition = false;
        
        _view.SetPlayerVisibility(true);
        _view.EndMergingEffect();
        
        // Allow the player to receive damage again
        _collider.enabled = true;
    }

    private IEnumerator ChangeSubmodule(int moduleIndex)
    {
        StartMergeAnimation(true);
        
        const float waitTime = 1f;
        yield return new WaitForSeconds(waitTime);

        EventManager.Instance.Trigger(EventManager.NameEvent.OnAbsorbedSubmodule, moduleIndex);
    }
	
    private void SetArm(bool isLeft, int armIndex)
    {
        UIManager.Instance.SetArmBar(isLeft, armIndex);
        
        if (isLeft)
        {
            _currentLeftArm = _model.leftArms[armIndex];
            _currentLeftArm.ResetEnergy();
            PlayerView.ShowArm(_model.leftArms, armIndex);
        }
        else
        {
            _currentRightArm = _model.rightArms[armIndex];
            _currentRightArm.ResetEnergy();
            PlayerView.ShowArm(_model.rightArms, armIndex);
        }
        
        EventManager.Instance.Trigger(EventManager.NameEvent.OnArmChanged);
    }
    
    /// <summary>
    /// Set the arm to change when the player absorb an enemy
    /// </summary>
    /// <param name="type"></param>
    /// <param name="isLeftArm"></param>
    private void SetArmToChange(Enemy.EnemyType type, bool isLeftArm)
    {
        var armIndex = GetArmSetIndex(type);

        SetArm(isLeftArm, armIndex);
    }
    
    private static int GetArmSetIndex(Enemy.EnemyType type)
    {
        return type switch
        {
            Enemy.EnemyType.LaserPorter => 1,
            Enemy.EnemyType.AssaultBox => 2,
            Enemy.EnemyType.Shielder => 3,
            Enemy.EnemyType.Blader => 4,
            _ => 0
        };
    }
    
    public void FixedUpdate()
    {
        if(IsPaused || _inMergeTransition || _isAbsorbing) 
            return;
        
        Move();
        RotateTorso();
    }
    
    private void Move()
    {
        if(_cantInteract) return;
        
        _horizontalMovement = Input.GetAxisRaw("Horizontal");
        _verticalMovement = Input.GetAxisRaw("Vertical");

        var movementDirection = new Vector3(_horizontalMovement, 0, _verticalMovement);

        Accelerate(movementDirection.normalized);
        
        if (movementDirection == Vector3.zero)
            _currentSpeed = 0;

        //_view.ShowDustVfx(_horizontalMovement, _verticalMovement);
        
        RotateLegs(movementDirection);
    }
    
    private void Accelerate(Vector3 dir)
    {
        if (_currentSpeed < _model.movementSpeed)
            _currentSpeed = _currentSpeed < _model.startingMovementSpeed ? _model.startingMovementSpeed : _currentSpeed + _model.acceleration;

        // Clamp max over speed
        _currentSpeed = _currentSpeed > _maxOverSpeed ? _maxOverSpeed : _currentSpeed;

        var speedAdjust = _currentSpeed - _model.movementSpeed;

        // Pull speed down if needed
        _currentSpeed -= speedAdjust > 0.0f ? speedAdjust * _pullDown : 0.0f;

        // Set the velocity magnitude to the new speed
        _rb.velocity = dir * _currentSpeed;
    }

    private void RotateLegs(Vector3 movementDirection)
    {
        if (movementDirection == Vector3.zero) 
            return;
        
        var toRotation = Quaternion.LookRotation(movementDirection, Vector3.up);
        _model.legs.transform.rotation = Quaternion.RotateTowards(_model.legs.transform.rotation, toRotation, (_model.rotationSpeed * 10) * Time.deltaTime);
    }
    
    private void RotateTorso()
    {
        var position = _model.torso.transform.position;
        var forward = _model.torso.transform.forward;
        
        var targetDelta = (new Vector3(InputManager.Instance.mousePosition.x, position.y, InputManager.Instance.mousePosition.z) - position).normalized;
        var angleToTarget = Vector3.Angle(forward, targetDelta);
        var turnAxis = Vector3.Cross(forward, targetDelta);

        _model.torso.transform.RotateAround(transform.position, turnAxis, Time.fixedDeltaTime * Mathf.Pow(2, _model.torsoSpeed) * angleToTarget);
        
        // Make sure torso only rotates in Y axis
        var rotation = _model.torso.transform.rotation;
        rotation = new Quaternion(0, rotation.y,0, rotation.w);
        _model.torso.transform.rotation = rotation;
    }
    
    private void OnCollisionExit(Collision other)
    {
        // Enemy
        if (other.gameObject.layer == 8)
            _rb.velocity = Vector3.zero;
    }

    public void TakeDamage(float damage)
    {
        // TODO: Do only for EDITOR
        if (!_godModeDisable)
            return;
        
        if (!_canTakeDamage)
            return;
        
        _model.SetCurrentHealth(_model.GetCurrentHealth() - damage);
        
        AudioManager.Instance.PlayAudioClip(Sounds.SoundType.PlayerDamaged, transform.position);
        UIManager.Instance.SetHealthBarValue(_model.GetCurrentHealth(), true, true);
        
        _percentage = (_model.GetCurrentHealth() / _model.hp) * 100;
        if (_percentage <= 40 && !_lowLife)
        {
            EventManager.Instance.Trigger(EventManager.NameEvent.OnLowLife, true);
            _lowLife = true;
        }
        
        if(_model.cantDie && _model.GetCurrentHealth() <= 0)
        {
            _model.SetCurrentHealth(1);
            UIManager.Instance.SetHealthBarValue(_model.GetCurrentHealth(), true, true);
        }

        if (!(_model.GetCurrentHealth() <= 0)) 
            return;

        if (BossManager.Instance.CheckFightSubmodule())
        {
            // Get the index of the current boss fight
            var index = FindObjectsOfType<SubBoss>()
                .Where(submodule => submodule.gameObject.activeInHierarchy)
                .ToList()
                .First()
                .GetSubmoduleIndex();
            
            EventManager.Instance.Trigger(EventManager.NameEvent.OnReturnedBoss, false, index);
            Destroy(gameObject);
            return;
        }
        
        var t = transform;
        Instantiate(_model.corpsePrefab, t.position, Quaternion.LookRotation(t.forward, t.up));
        Instantiate(_model.deathParticles, transform.position + Vector3.up * .5f, Quaternion.identity);
        _model.KillEntity();
    }
    
    private void HealPlayer(float amount)
    {
        _model.SetCurrentHealth(_model.GetCurrentHealth() + amount);

        if (_model.GetCurrentHealth() > _model.hp)
            _model.SetCurrentHealth(_model.hp);
        
        _percentage = (_model.GetCurrentHealth() / _model.hp) * 100;
        if (_percentage > 40 && _lowLife)
        {
            EventManager.Instance.Trigger(EventManager.NameEvent.OnLowLife, false);
            _lowLife = false;
        }
        
        UIManager.Instance.SetHealthBarValue(_model.GetCurrentHealth(), false, true);
    }

    public bool GetIfLowLife()
    {
        return _lowLife;
    }

    private void ResetPlayerMovement()
    {
        _horizontalMovement = 0;
        _verticalMovement = 0;
        
        _rb.velocity = Vector3.zero;
    }
    
    /// <summary>
    /// Happens when the player return to the main fight
    /// </summary>
    /// <param name="parameters"></param>
    private void OnReturnedBoss(params object[] parameters)
    {
        if(this == null) 
            return;
        
        const float time = 0.2f;
        Invoke(nameof(ResetPlayerMovement), time);
        
        ReturnBarsValues();


        if (_model.startingArm != PlayerArm.ArmType.BasicArm)
            return;

        // Do this only if is the player from the main fight
        ReturnFromSubmodule();
    }
    
    private void OnTextStarted(params object[] parameters)
    {
        _cantInteract = true;
    }
    
    private void OnTextFinished(params object[] parameters)
    {
        _cantInteract = false;
    }
    
    private void ReturnFromSubmodule()
    {
        Vector3 newPos;
        var canTeleport = false;

        // Wall layer mask
        LayerMask wallMask = 7;
            
        do
        {
            newPos = new Vector3(Random.Range(_model.minReturnDistance, _model.maxReturnDistance), 
                transform.position.y, 
                Random.Range(_model.minReturnDistance, _model.maxReturnDistance));
                
            var colliders = Physics.OverlapSphere(newPos, 1f, wallMask);

            if (colliders.Length != 0) 
                continue;
            
            canTeleport = true;
            
        } while (!canTeleport);

        _lastNewPosition = newPos;
        
        var particleForce = Instantiate(_model.particleForceField, newPos, Quaternion.identity);
        _view.ShowMergingEffect(particleForce);

        Invoke(nameof(DelayedEndMergeAnimation), 1f);
    }
    
    private void DelayedEndMergeAnimation()
    {
        Destroy(_lastForceField);
        EndMergeAnimation(_lastNewPosition);
    }
    
    /// <summary>
    /// Set the current values of the ui bars when the player
    /// return to the main boss fight
    /// </summary>
    private void ReturnBarsValues()
    {
        // Make sure the active player set the current bars values
        if (!gameObject.activeInHierarchy)
            return;
        
        var leftIndex = _model.leftArms.IndexOf(_currentLeftArm);
        var rightIndex = _model.rightArms.IndexOf(_currentRightArm);
        
        UIManager.Instance.SetArmBar(true, leftIndex);
        UIManager.Instance.SetArmBar(false, rightIndex);
        
        _currentLeftArm.ForceUIBarValue();
        _currentRightArm.ForceUIBarValue();
        
        UIManager.Instance.SetHealthBarValue(_model.GetCurrentHealth(), false, true);
    }

    public int GetCurrentArm(bool isLeft)
    {
        return isLeft ? _model.leftArms.IndexOf(_currentLeftArm) : _model.rightArms.IndexOf(_currentRightArm);
    }

    public float GetArmEnergy(bool isLeft)
    {
        return isLeft ? _currentLeftArm.GetDuration() : _currentRightArm.GetDuration();
    }

    public void SetCantHeal(bool cantHeal)
    {
        _cantHeal = cantHeal;
    }

    public void SetCantChangeArm(bool cantChangeArm)
    {
        _cantChangeArm = cantChangeArm;
    }
    
    public Tuple<PlayerArm, PlayerArm> GetCurrentArmsType()
    {
        return new Tuple<PlayerArm, PlayerArm>(_currentLeftArm, _currentRightArm);
    }
}
