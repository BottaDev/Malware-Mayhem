using System.Collections;
using MM.Entities.Player.Arms;
using MM.Entities.Player;
using MM.Cam;
using MM.Events;
using MM.Gameplay;
using MM.Sound;
using UnityEngine;
using UnityEngine.AI;
using Random = UnityEngine.Random;

namespace MM.Entities.Enemies
{
    [RequireComponent(typeof(FOV))]
    public abstract class Enemy : Entity
    {
        #region Private Variables
        [Header("Enemy Parameters")]
        [SerializeField] private EnemyType type;
        [SerializeField, Range(0, 100)] private float stunPercentageChance = 50f;
        [SerializeField] private float stunTime = 5f;
        [Tooltip("The percentage that the enemy recovers when leaving the stun state")]
        [SerializeField, Range(1, 100)] private float recoveryPercentage = 30f;
        [SerializeField] protected bool isStunned;
        [SerializeField] protected bool forceStun;
        [SerializeField] private bool cantStun;
        [SerializeField] private bool cantRecover;
        [SerializeField] private bool cantDie;
        
        [Space(15)]
        [SerializeField] protected GameObject corpsePrefab;
        [SerializeField] protected GameObject deathParticles;
        [SerializeField] protected GameObject stunnedParticles;
        [SerializeField] protected GameObject onStunParticles;
        [SerializeField] protected GameObject absorbImg;
        [SerializeField] protected Material stunnedMaterials;
        
        protected PlayerModel _player;
        protected NavMeshAgent _agent;
        protected CameraShaker _cameraShaker;
        protected float _distanceToPlayer;
        protected float _currentMovementSpeed;
        protected FOV _fov;
        
        private  bool _isDead;
        private bool _isInvulnerable;
        private bool _wasStunned;
        private Rigidbody _rb;
        private bool _onTransition;  // Used to stop the movement when the enemy is dying on scene transition (modules)
        #endregion

        #region MonoBehaviour Functions
        protected override void Awake()
        {
            base.Awake();
        
            _agent = GetComponent<NavMeshAgent>();
            _rb = GetComponent<Rigidbody>();
            _fov = GetComponent <FOV>();
            _cameraShaker = GetComponent<CameraShaker>();
        
            absorbImg.SetActive(false);
            _currentMovementSpeed = movementSpeed;
        }
    
        private void Start()
        {
            EventManager.Instance.Subscribe(NameEvent.OnAbsorbedSubmodule, OnAbsorbedSubmodule);
            EventManager.Instance.Subscribe(NameEvent.OnBossDeath, OnBossDeath);
        }

        public virtual void Update()
        {
            if (CheckPlayer() || PauseManager.Instance.IsPaused)
                return;
        
            SetAISpeed();

            _distanceToPlayer = Vector3.Distance(transform.position, _player.transform.position);

            if (!isStunned)
            {
                Move();
                MakeActions();   
            }
        }
        #endregion
        
        #region Private Functions
        /// <summary>
        /// Check if the player exists in the level
        /// </summary>
        /// <returns></returns>
        private bool CheckPlayer()
        {
            if (_player == null)
                _player = LevelManager.Instance.Player;

            return _player == null;
        }
    
        private void SetAISpeed()
        {
            _agent.speed = _currentMovementSpeed;
        }

        protected void RotateTowards (Vector3 target) 
        {
            Vector3 direction = (target - transform.position).normalized;
            Quaternion lookRotation = Quaternion.LookRotation(new Vector3(direction.x, 0, direction.z));
            transform.rotation = Quaternion.Slerp(transform.rotation, lookRotation, Time.deltaTime * rotationSpeed);
        }
    
        protected void MoveToPosition(Vector3 position)
        {
            if (_onTransition ||
                _agent.destination == Vector3.positiveInfinity)
            {
                return;   
            }

            _agent.destination = position;
        }
    
        protected virtual void Move() { }
    
        protected virtual void MakeActions() { }

        private void OnCollisionExit(Collision other)
        {
            // Enemy, Player
            if (other.gameObject.layer is 8 or 9)
                _rb.velocity = Vector3.zero;
        }

        protected virtual IEnumerator StunEnemy()
        {
            _isInvulnerable = true;
            absorbImg.gameObject.SetActive(true);
            _wasStunned = true;
            isStunned = true;
            _currentMovementSpeed = 0;
        
            if (_agent.enabled)
                _agent.isStopped = true;

            const float resetTime = 1f;
            Invoke(nameof(ResetInvulnerability), resetTime);
        
            Instantiate(onStunParticles, transform.position, Quaternion.identity);
            var ps = Instantiate(stunnedParticles, transform);
            ps.transform.localPosition = transform.up;
        
            // Ensure that the player can merge the enemy while it's stunned...
            if (forceStun)
                yield break;
        
            if(cantRecover)
                yield break;
        
            yield return new WaitForSeconds(stunTime);

            // Ensure that the player can merge the enemy while it's stunned...
            if (forceStun)
                yield break;
        
            for (var i = 0; i < allRenderers.Length; i++)
                allRenderers[i].material = baseMats[i];
        
            Destroy(ps);
            absorbImg.gameObject.SetActive(false);

            if(_agent.enabled)
                _agent.isStopped = false;

            RecoverFromStun();
        }

        protected virtual void RecoverFromStun()
        {
            // Ensure that the player can merge the enemy while it's stunned...
            if (forceStun)
                return;
        
            isStunned = false;
        
            ResetMovementSpeed();
        
            var newHp = (recoveryPercentage * hp) / 100;
            _currentHp = newHp;
        }
    
        private void ResetInvulnerability()
        {
            _isInvulnerable = false;
        }

        protected override IEnumerator ShowDamage()
        {
            foreach (var item in allRenderers)
                item.material = damagedMat;

            yield return new WaitForSeconds(.1f);

            for (var i = 0; i < allRenderers.Length; i++)
                allRenderers[i].material = isStunned ? stunnedMaterials : baseMats[i];
        }

        private void ResetMovementSpeed()
        {
            _currentMovementSpeed = movementSpeed;
        }
    
        /// <summary>
        /// Should be called only when the boss is killed
        /// </summary>
        private void KillEnemyByTime()
        {
            var transform1 = transform;
            Instantiate(corpsePrefab, transform1.position, Quaternion.LookRotation(transform1.forward, transform1.up));
            Instantiate(deathParticles, transform.position + Vector3.up * .5f, Quaternion.identity);
        
            KillEntity();
        }
        #endregion
        
        #region Public Functions
        public override void TakeDamage(float damage, PlayerArm.ArmType aType = PlayerArm.ArmType.None, bool showDamage = true)
        {
            if (_isInvulnerable)
                return;
     
            if(showDamage)
                StartCoroutine(ShowDamage());
        
            _currentHp -= damage;
        
            AudioManager.Instance.PlayAudioClip(Sounds.SoundType.EnemyDamaged, transform.position);

            if (_currentHp <= 0 && !_wasStunned && (Random.value < stunPercentageChance * 0.01f) && !cantStun)
            {
                EventManager.Instance.Trigger(NameEvent.OnStunnedEnemy);
                StartCoroutine(StunEnemy());   
            }
            else if (_currentHp <= 0 && !_isDead && !cantDie)
            {
                var transform1 = transform;
                Instantiate(corpsePrefab, transform1.position, Quaternion.LookRotation(transform1.forward, transform1.up));
                Instantiate(deathParticles, transform.position + Vector3.up * .5f, Quaternion.identity);
                KillEntity();
            }
        }
        
        public bool GetIsStunned()
        {
            return isStunned;
        }

        public FOV GetFov()
        {
            return _fov;
        }
        
        public override void KillEntity()
        {
            _cameraShaker.ShakeCamera();
        
            _isDead = true;
            EventManager.Instance.Trigger(NameEvent.OnEnemyDead, type);
        
            AudioManager.Instance.PlayAudioClip(Sounds.SoundType.EnemyDead, transform.position);
            base.KillEntity();
        }
        
        /// <summary>
        /// Ensure that the enemy is stunned when the player merge
        /// </summary>
        public void ForceStun()
        {
            forceStun = true;
        }

        public EnemyType GetType()
        {
            return type;
        }
        #endregion
    
        #region Events
        private void OnAbsorbedSubmodule(params object[] parameters)
        {
            _onTransition = true;
        }

        /// <summary>
        /// Should kill the enemy when the boss dies
        /// </summary>
        /// <param name="parameters"></param>
        private void OnBossDeath(params object[] parameters)
        {
            if (_isDead || 
                this == null || 
                !gameObject.activeInHierarchy)
                return;

            const float time = 0.3f;
            Invoke(nameof(KillEnemyByTime), time);
        }
        #endregion
        
        public enum EnemyType
        {
            LaserPorter,
            AssaultBox,
            Shielder,
            Blader
        }
    }
}
