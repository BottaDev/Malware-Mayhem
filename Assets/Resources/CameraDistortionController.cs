using System.Collections;
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.Rendering.PostProcessing;

public class CameraDistortionController : MonoBehaviour
{
    // TO DO: get the position of the module in the screen and center the vignette/distortion on it
    //public Transform distortTarget;

    float progress;
    Vignette vignette;
    LensDistortion lensDistortion;
    ChromaticAberration chromaticAberration;
    CameraDistortionPPSSettings cameraDistortion;
    PostProcessVolume volume;

    private void Start()
    {
        volume = gameObject.GetComponent<PostProcessVolume>();
        volume.profile.TryGetSettings(out vignette);
        volume.profile.TryGetSettings(out lensDistortion);
        volume.profile.TryGetSettings(out chromaticAberration);
        volume.profile.TryGetSettings(out cameraDistortion);
        volume.weight = 0;
    }

    private void OnEnable()
    {
        EventManager.Instance.Subscribe(EventManager.NameEvent.OnAbsorbedSubmodule, StartEffect);
        EventManager.Instance.Subscribe(EventManager.NameEvent.OnReturnedBoss, EffectOut);
    }
    private void OnDisable()
    {
        EventManager.Instance.Unsubscribe(EventManager.NameEvent.OnAbsorbedSubmodule, StartEffect);
        EventManager.Instance.Subscribe(EventManager.NameEvent.OnReturnedBoss, EffectOut);
    }


    public void StartEffect(params object[] parameter)
    {
        volume.weight = 1;
        StartCoroutine(VFXCoroutine());
        StartCoroutine(LensDistortionCoroutine());
    }

    public void EffectOut(params object[] parameter)
    {
        volume.weight = 1;
        StartCoroutine(VFXOut());
    }

    IEnumerator VFXCoroutine()
    {
        float duration = 1.5f;
        int steps = 60;
        
        for (int i = 0; i <= steps; i++)
        {
            progress = Mathf.Lerp(0, 1, (float)i / (float)steps);

            cameraDistortion._NoiseScale.value = Mathf.Lerp(0, 15, progress);
            vignette.intensity.value = Mathf.Lerp(0, 1, progress);
            chromaticAberration.intensity.value = Mathf.Lerp(0, 1, progress);

            yield return new WaitForSecondsRealtime(duration/steps);
        }
    }

    IEnumerator LensDistortionCoroutine()
    {
        float duration = .5f;
        int steps = 20;

        for (int i = 0; i <= steps; i++)
        {
            lensDistortion.intensity.value = Mathf.Lerp(0, -70, (float)i / (float)steps);
            yield return new WaitForSecondsRealtime(duration / steps);
        }

        duration = 1;
        steps = 40;
        for (int i = 0; i <= steps; i++)
        {
            lensDistortion.intensity.value = Mathf.Lerp(0, 70, (float)i / (float)steps);
            yield return new WaitForSecondsRealtime(duration / steps);
        }

        StartCoroutine(VFXOut());
    }

    IEnumerator VFXOut()
    {
        float duration = .5f;
        int steps = 20;

        for (int i = 0; i <= steps; i++)
        {
            progress = Mathf.Lerp(0, 1, (float)i / (float)steps);

            cameraDistortion._NoiseScale.value = Mathf.Lerp(15, 0, progress);
            vignette.intensity.value = Mathf.Lerp(1, 0, progress);
            lensDistortion.intensity.value = Mathf.Lerp(70, 0, progress);
            chromaticAberration.intensity.value = Mathf.Lerp(1, 0, progress);

            yield return new WaitForSecondsRealtime(duration / steps);
        }

        volume.weight = 0;
    }
}
