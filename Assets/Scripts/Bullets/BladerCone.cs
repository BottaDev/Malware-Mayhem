using System.Collections;
using MM.Entities.Player.Arms;
using MM.Entities;
using MM.Entities.Enemies.Bosses;
using UnityEngine;

namespace MM.Bullets
{
    /// <summary>
    /// The area of the melee attack
    /// </summary>
    public class BladerCone : MonoBehaviour
    {
        #region Private Variables
        
        [SerializeField] private float damage;
        [SerializeField] private LayerMask destroyMask;
        [SerializeField] private Texture[] textures;
    
        private MeshRenderer _mr;
        
        #endregion
    
        #region MonoBehaviour Functions
        
        private void Awake()
        {
            _mr = GetComponent<MeshRenderer>();
        }
        
        private void OnEnable()
        {
            StartCoroutine(Animate());
        }

        private void OnTriggerEnter(Collider other)
        {
            MakeDamage(other);
        }
        #endregion

        #region Private Functions
        private void MakeDamage(Collider other)
        {
            if (destroyMask != (destroyMask | (1 << other.gameObject.layer))) { return; }
        
            switch (other.gameObject.layer)
            {
                // BouncingBullet
                case 20:
                    if (other.TryGetComponent<BouncingBossBullets>(out var bullet))
                    {
                        // Calculate the direction in the local space of the child object (the one with the collider)
                        var localDirectionToCollider = other.transform.localPosition - transform.localPosition;

                        // Transform that local direction to world space, considering the rotation and position of the parent object
                        var worldDirectionToCollider = transform.parent.TransformDirection(localDirectionToCollider);

                        var bounceNormal = other.transform.forward;

                        // Multiply the direction by -1 to get the right direction
                        bullet.Bounce(worldDirectionToCollider.normalized * -1, bounceNormal);
                    }
                    break;
                // Enemy, Player
                case 8 or 9:
                    if (other.TryGetComponent<Entity>(out var entity))
                    {
                        entity.TakeDamage(damage, PlayerArm.ArmType.BladeArm);
                    }
                    else
                    {
                        Debug.LogError("Entity not found on blader cone");
                    }
                    
                    break;
            
                // Submodule
                case 6:
                    if(other.TryGetComponent<BossSubmodule>(out var submodule))
                    {
                        submodule.TakeDamage(damage, PlayerArm.ArmType.BladeArm);
                    }
                    else
                    {
                        Debug.LogError("Submodule not found on blader cone");
                    }
                    
                    break;
            }
        }

        private IEnumerator Animate()
        {
            const float duration = .25f;
            const int steps = 30;

            for (var i = 0; i < 30; i++)
            {
                var currentTexture = (int)((i / (float)steps) * textures.Length);

                if(currentTexture < textures.Length)
                {
                    _mr.material.mainTexture = textures[currentTexture];
                }   

                yield return new WaitForSeconds( duration/steps);
            }
        }
        #endregion
    }
}
