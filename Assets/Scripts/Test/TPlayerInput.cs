using System;
using System.Collections;
using System.Collections.Generic;
using System.Linq;
using UnityEngine;

public class TPlayerInput : MonoBehaviour
{
    [Header("General Parameters")]
    public float speed = 10f;
    public float rotationSpeed = 100f;
    [Header("Torso Parameters")] 
    public float torsoSpeed = 5f;
    public GameObject torso;
    [Header("Shot Parameters")] 
    public float fireRate = 0.3f;
    public GameObject shotPrefab;
    public Transform rightShotSpawn;
    public Transform leftShotSpawn;

    private float _horizontalMovement;
    private float _verticalMovement;
    private float _currentRightFireRate = 0;
    private float _currentLeftFireRate = 0;

    private List<MeshRenderer> _meshRenderers = new List<MeshRenderer>();
    private List<Color> _defaultColors = new List<Color>();

    private void Awake()
    {
        _meshRenderers = transform.GetComponentsInChildren<MeshRenderer>().ToList();
        
        foreach (var mesh in _meshRenderers)
        {
            _defaultColors.Add(mesh.material.color);
        }
    }
    
    private void Update()
    {
        if (Input.GetMouseButton(1) && _currentRightFireRate <= 0 && !Input.GetKey(KeyCode.LeftControl))
            Shoot(rightShotSpawn, false);
        else
            _currentRightFireRate -= Time.deltaTime;
        
        if (Input.GetMouseButton(0) && _currentLeftFireRate <= 0 && !Input.GetKey(KeyCode.LeftControl))
            Shoot(leftShotSpawn, true);
        else
            _currentLeftFireRate -= Time.deltaTime;
    }

    private void FixedUpdate()
    {
        ProcessInput();
        RotateTorso();
    }
    
    private void Shoot(Transform spawnPos, bool left)
    {
        Instantiate(shotPrefab, spawnPos.position, spawnPos.rotation);

        if (left)
            _currentLeftFireRate = fireRate;
        else
            _currentRightFireRate = fireRate;
    }

    private void ProcessInput()
    {
        _horizontalMovement = Input.GetAxisRaw("Horizontal");
        _verticalMovement = Input.GetAxisRaw("Vertical");

        Vector3 movementDirection = new Vector3(_horizontalMovement, 0, _verticalMovement);
        movementDirection.Normalize();
        
        transform.Translate(movementDirection * speed * Time.deltaTime, Space.World);

        if (movementDirection != Vector3.zero)
        {
            Quaternion toRotation = Quaternion.LookRotation(movementDirection, Vector3.up);
            transform.rotation =
                Quaternion.RotateTowards(transform.rotation, toRotation, (rotationSpeed * 10) * Time.deltaTime);
        }
    }
    
    private void OnTriggerEnter(Collider other)
    {
        if (other.gameObject.layer == 11)
            StartCoroutine(Blink());
    }
    
    // Change the color to RED when damaged
    private IEnumerator Blink()
    {
        foreach (var mesh in _meshRenderers)
        {
            mesh.material.color = Color.red;
        }
        
        yield return new WaitForSeconds(0.2f);
        
        for (int i = 0; i < _meshRenderers.Count; i++)
        {
            _meshRenderers[i].material.color = _defaultColors[i];
        }
        
        yield return null;
    }
    
    private void RotateTorso()
    {
        Vector3 targetDelta = new Vector3(InputManager.Instance.mousePosition.x, torso.transform.position.y, InputManager.Instance.mousePosition.z) - torso.transform.position;
        float angleToTarget = Vector3.Angle(torso.transform.forward, targetDelta);
        Vector3 turnAxis = Vector3.Cross(torso.transform.forward, targetDelta);
 
        torso.transform.RotateAround(transform.position, turnAxis, Time.deltaTime * torsoSpeed * angleToTarget);
        
        // Make sure torso only rotates in Y axis
        torso.transform.rotation = new Quaternion(0, torso.transform.rotation.y,0,torso.transform.rotation.w);
    }
}
