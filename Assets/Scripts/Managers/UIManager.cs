using System.Collections;
using System.Collections.Generic;
using MM.Common;
using MM.Events;
using MM.Gameplay;
using UnityEngine;
using DG.Tweening;
using MM.Entities.Enemies;
using MM.Entities.Player;
using TMPro;
using UnityEngine.UI;

namespace MM.UI
{
    /// <summary>
    /// Manage the UI elements of the game.
    /// </summary>
    public class UIManager : MonoBehaviourSingleton<UIManager>
    {
        #region Private Variables

        [Header("[HUD] Player")] 
        [SerializeField] private UIHealthBar playerHealthBar;
        [SerializeField] private List<UIBar> leftBars = new();
        [SerializeField] private List<UIBar> rightBars = new();
        [SerializeField] private GameObject playerBars;
        [SerializeField] private Transform finalPosition;
        [SerializeField] private float animDuration;

        [Header("[HUD] Boss")] 
        [SerializeField] private UIHealthBar bossHealthBar;
        [SerializeField] private GameObject bossHealthBarContainer;
        [SerializeField] private Image bossImage;

        [Header("Pause Menu")] 
        [SerializeField] private GameObject hud;
        [SerializeField] private GameObject pauseMenu;
        [SerializeField] private GameObject optionsMenu;

        [Header("Fade")] 
        [SerializeField] private GameObject fadeIn;

        [Header("Absorb Menu")] 
        [SerializeField] private GameObject absorbMenu;
        [SerializeField] private GameObject[] armsGroup;
        [SerializeField] private GameObject healGroup;
        [SerializeField] private GameObject[] currentLeftArms;
        [SerializeField] private GameObject[] futureLeftArms;
        [SerializeField] private GameObject[] currentRightArms;
        [SerializeField] private GameObject[] futureRightArms;

        [Header("TextBox")] 
        [SerializeField] private GameObject textBox;
        [SerializeField] private GameObject continueText;

        private UIBar _currentLeftUIBar;
        private UIBar _currentRightUIBar;
        private List<GameObject> _screens;
        private bool _canRefresh = true;
        private bool _playerSpawn;
        private PlayerController _playerController;

        private const float _maxArmValue = 100f;

        #endregion

        #region MonoBehaviour Functions

        protected override void Awake()
        {
            base.Awake();

            InitializeArmBars();

            _currentLeftUIBar = leftBars[0];
            _currentRightUIBar = rightBars[0];

            _screens = new List<GameObject>
            {
                hud,
                pauseMenu,
                optionsMenu
            };

            StartCoroutine(nameof(WaitToPlayer));
        }

        private void Start()
        {
            EventManager.Instance.Subscribe(NameEvent.OnReturnedBoss, OnReturnedBoss);
            EventManager.Instance.Subscribe(NameEvent.OnAbsorbedSubmodule, OnAbsorbedSubmodule);
            EventManager.Instance.Subscribe(NameEvent.OnPostProcessFinished, OnPostProcessFinished);
            EventManager.Instance.Subscribe(NameEvent.OnPlayerSpawned, OnPlayerSpawned);
            EventManager.Instance.Subscribe(NameEvent.OnTextStarted, OnTextStarted);
            EventManager.Instance.Subscribe(NameEvent.OnTextFinished, OnTextFinished);
        }

        #endregion

        #region Public Functions

        public void Resume()
        {
            PauseManager.Instance.ResumeLevel();
        }

        public void ResumeLevel()
        {
            ShowScreen(hud);
        }

        public void ExitLevel()
        {
            PauseManager.SetLevelSpeed(1);
            SceneLoader.Instance.MainMenu();
        }

        public void RestartLevel()
        {
            PauseManager.SetLevelSpeed(1);
            SceneLoader.RetryCurrentLevel();
        }

        public void PauseLevel()
        {
            ShowScreen(pauseMenu);
        }

        public void ShowOptions()
        {
            ShowScreen(optionsMenu);
        }

        public void SetArmEnergy(bool isLeft, float value)
        {
            // Should ignore when is the basic arm
            switch (isLeft)
            {
                case true when _currentLeftUIBar != leftBars[0]:
                    _currentLeftUIBar.SetValue(value);
                    break;
                case false when _currentRightUIBar != rightBars[0]:
                    _currentRightUIBar.SetValue(value);
                    break;
            }
        }

        public void SetArmBar(bool isLeft, int index)
        {
            var bars = isLeft ? leftBars : rightBars;

            foreach (var bar in bars)
            {
                bar.gameObject.SetActive(false);
            }

            bars[index].gameObject.SetActive(true);

            if (isLeft)
            {
                _currentLeftUIBar = bars[index];
            }
            else
            {
                _currentRightUIBar = bars[index];
            }

            bars[index].SetValue(_maxArmValue);
        }

        public void SetHealthBarValue(float newHealth, bool takingDamage, bool isPlayer)
        {
            var healthBar = isPlayer ? playerHealthBar : bossHealthBar;

            healthBar.SetValue(newHealth);

            StartCoroutine(takingDamage ? healthBar.BlinkBar(Color.red) : healthBar.BlinkBar(Color.green));
        }

        public void SetMaxHealth(float newHealth, bool isPlayer)
        {
            var healthBar = isPlayer ? playerHealthBar : bossHealthBar;
            healthBar.SetMaxValue(newHealth);
        }

        public void StartFadeIn()
        {
            ShowScreen(fadeIn);
        }

        public void ToggleAbsorbMenu(bool active)
        {
            absorbMenu.SetActive(active);

            if (!active) { return; }
            
            foreach (var current in currentLeftArms)
            {
                current.SetActive(false);
            }
                
            foreach (var current in currentRightArms)
            {
                current.SetActive(false);
            }

            foreach (var future in futureLeftArms)
            {
                future.SetActive(false);
            }

            foreach (var future in futureRightArms)
            {
                future.SetActive(false);
            }
                
            var currentLeftArm = _playerController.GetCurrentArm(true);
            var currentRightArm = _playerController.GetCurrentArm(false);
            var currentEnemy = _playerController.GetCloseEnemy();

            switch (currentEnemy.GetType())
            {
                case Enemy.EnemyType.LaserPorter:
                    futureLeftArms[0].SetActive(true);
                    futureRightArms[0].SetActive(true);
                    break;
                case Enemy.EnemyType.AssaultBox:
                    futureLeftArms[1].SetActive(true);
                    futureRightArms[1].SetActive(true);
                    break;
                case Enemy.EnemyType.Blader:
                    futureLeftArms[2].SetActive(true);
                    futureRightArms[2].SetActive(true);
                    break;
            }
            
            switch (currentLeftArm)
            {
                case 0:
                    currentLeftArms[0].SetActive(true);
                    break;
                case 1:
                    currentLeftArms[1].SetActive(true);
                    break;
                case 2:
                    currentLeftArms[2].SetActive(true);
                    break;
                case 4:
                    currentLeftArms[3].SetActive(true);
                    break;
            }

            switch (currentRightArm)
            {
                case 0:
                    currentRightArms[0].SetActive(true);
                    break;
                case 1:
                    currentRightArms[1].SetActive(true);
                    break;
                case 2:
                    currentRightArms[2].SetActive(true);
                    break;
                case 4:
                    currentRightArms[3].SetActive(true);
                    break;
            }
        }

        public void SetBossHealthVisibility(bool visible)
        {
            bossHealthBarContainer.SetActive(visible);
        }
        
        public void SetBossImage(Sprite sprite)
        {
            bossImage.sprite = sprite;
        }

        public void ChangeStatus(bool status)
        {
            _canRefresh = status;
        }

        public TextMeshProUGUI GetTextBox()
        {
            return textBox.GetComponentInChildren<TextMeshProUGUI>();
        }

        public void SetMergingUI(bool viewArms, bool viewHeal)
        {
            foreach (var armGroup in armsGroup)
            {
                armGroup.SetActive(viewArms);
            }
            healGroup.SetActive(viewHeal);
        }

        #endregion

        #region Private Functions

        /// <summary>
        /// Shows the given screen and hides the others.
        /// </summary>
        /// <param name="screen">The screen that will be visible</param>
        private void ShowScreen(GameObject screen)
        {
            foreach (var s in _screens)
            {
                s.SetActive(false);
            }

            screen.SetActive(true);
        }

        /// <summary>
        /// Set the MaxValue of the arm bars.
        /// </summary>
        private void InitializeArmBars()
        {
            foreach (var bar in leftBars)
            {
                bar.SetMaxValue(_maxArmValue);
            }

            foreach (var bar in rightBars)
            {
                bar.SetMaxValue(_maxArmValue);
            }
        }
        
        /// <summary>
        /// This is the initial animation of the UI.
        /// </summary>
        /// <returns></returns>
        private IEnumerator MoveUI()
        {
            yield return new WaitForSecondsRealtime(animDuration);
            SetPlayerAsChild();
        }

        /// <summary>
        /// Finish the animation of the UI.
        /// </summary>
        private void SetPlayerAsChild()
        {
            playerBars.transform.parent = finalPosition;
            var finalRectTrans = finalPosition.GetComponent<RectTransform>();
            playerBars.transform.position = finalRectTrans.position;
        }

        private IEnumerator RefreshUI()
        {
            yield return new WaitUntil(() => _canRefresh);

            var time = 0f;

            // Check if it's the main fight or a submodule fight
            var playerSpawn = FindObjectOfType<PlayerSpawn>();

            time = playerSpawn != null ? playerSpawn.GetFallDelay() : 1f;

            yield return new WaitForSeconds(time);

            var playerModel = LevelManager.Instance.Player;

            SetHealthBarValue(playerModel.GetCurrentHealth(), false, true);
            SetArmBar(true, playerModel.GetCurrentArm(true));
            SetArmBar(false, playerModel.GetCurrentArm(false));
            SetArmEnergy(true, playerModel.GetArmEnergy(true));
            SetArmEnergy(false, playerModel.GetArmEnergy(false));
        }
        
        /// <summary>
        /// Show the continue text when the text is finished.
        /// </summary>
        private IEnumerator ShowContinueText()
        {
            yield return new WaitUntil(() => TextBoxManager.Instance.FinishedTyping);
            continueText.SetActive(true);
        }
        
        private IEnumerator WaitToPlayer()
        {
            yield return new WaitUntil(() => _playerSpawn);
            EventManager.Instance.Unsubscribe(NameEvent.OnPlayerSpawned, OnPlayerSpawned);
    
            _playerController = GameObject.FindWithTag("Player").GetComponent<PlayerController>();
        }

        #endregion
        
        #region Events Functions

        private void OnReturnedBoss(params object[] parameters)
        {
            _canRefresh = false;
            SetBossHealthVisibility(true);
        }

        private void OnAbsorbedSubmodule(params object[] parameters)
        {
            _canRefresh = false;
            SetBossHealthVisibility(false);
        }

        private void OnPostProcessFinished(params object[] parameters)
        {
            StartCoroutine(RefreshUI());
        }

        private void OnPlayerSpawned(params object[] parameters)
        {
            _playerSpawn = true;
            playerBars.SetActive(true);
            var finalRectTrans = finalPosition.GetComponent<RectTransform>();
            playerBars.GetComponent<RectTransform>().transform.DOMove(finalRectTrans.position, animDuration)
                .SetEase(Ease.InOutSine);
            StartCoroutine(MoveUI());
        }
        
        private void OnTextStarted(params object[] parameters)
        {
            textBox.SetActive(true);
            continueText.SetActive(false);
            StartCoroutine(nameof(ShowContinueText));
        }

        private void OnTextFinished(params object[] parameters)
        {
            textBox.SetActive(false);
            continueText.SetActive(false);
        }

        #endregion
    }
}